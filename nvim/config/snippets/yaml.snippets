# Generated by snippet-converter.nvim (https://github.com/smjonas/snippet-converter.nvim)

# =======================
# Docker-compose snippets
# =======================
snippet ar 
	args:
			${1:name}: ${2:value}
snippet bu 
	build:
			${1:value}
snippet cpu_q 
	cpu_quota: ${1:value}
snippet cpus 
	cpuset: ${1:value}
snippet cpu_s 
	cpu_shares: ${1:value}
snippet cap_a 
	cap_add:
			- ${1:value}
snippet cap_d 
	cap_drop:
			- ${1:value}
snippet com 
	command: ${1:command}
snippet conta 
	container_name: ${1:name}
snippet conte 
	context: ${1:dir}
snippet dn 
	dns:
			- ${1:ip}
snippet dns_ 
	dns_search:
			- ${1:ip}
snippet dep 
	depends_on:
			${1:value}
snippet dev 
	devices:
			- ${1:value}
snippet doc 
	dockerfile: ${1:file}
snippet dom 
	domainname: ${1:name}
snippet driver 
	driver: ${1:value}
snippet driver_ 
	driver_opts:
			${1:key}: ${2:value}
snippet ent 
	entrypoint: ${1:command}
snippet env_ 
	env_file:
			- ${1:file}
snippet env 
	environment:
			${1:name}: ${2:value}
snippet exp 
	expose:
			- ${1:port}
snippet exten 
	extends:
			file: ${1:file}
			service: ${2:name}
snippet exter 
	external: ${1:boolean}
snippet extr 
	extra_hosts:
			- ${1:host}:${2:ip}
snippet gr 
	group_add:
			- ${1:name}
snippet hc 
	healthcheck:
			test: ${1:command}
snippet ho 
	hostname: ${1:name}
snippet ipa 
	ipam:
			${1:value}
snippet ipc 
	ipc: ${1:host}
snippet im 
	image: ${1:image}
snippet ipv4 
	ipv4_address: ${1:ip}
snippet ipv6 
	ipv6_address: ${1:ip}
snippet la 
	labels:
			${1:dns}: ${2:label}
snippet link_ 
	link_local_ips:
			- ${1:ip}
snippet links 
	links:
			- ${1:name}
snippet log_d 
	log_driver: ${1:driver}
snippet log_o 
	log_opt:
			${1:value}
snippet logg 
	logging:
			driver: ${1:driver}
			options:
				${2:value}
snippet mems 
	memswap_limit: ${1:value}
snippet mem_ 
	mem_limit: ${1:value}
snippet net 
	net: ${1:value}
snippet network_ 
	network_mode: ${1:value}
snippet networks 
	networks:
			- ${1:value}
snippet oom 
	oom_score_adj: ${1:value}
snippet pi 
	pid: ${1:host}
snippet po 
	ports:
			- ${1:value}
snippet pr 
	privileged: ${1:boolean}
snippet rea 
	read_only: ${1:boolean}
snippet res 
	restart: ${1:value}
snippet sh 
	shm_size: ${1:value}
snippet sec 
	security_opt:
			- ${1:value}
snippet ser 
	services:
			${1:name}
snippet std 
	stdin_open: ${1:boolean}
snippet sto 
	stop_signal: ${1:signal}
snippet tt 
	tty: ${1:boolean}
snippet ul 
	ulimits:
			${1:value}
snippet us 
	user: ${1:value}
snippet ver 
	version: '${1:3}'
snippet volume_ 
	volume_driver: ${1:driver}
snippet volumes 
	volumes:
			- ${1:value}
snippet volumes_ 
	volumes_from:
			- ${1:name}
snippet wo 
	working_dir: ${1:dir}
snippet cgr 
	cgroup_parent: ${1:cgroup}
snippet tm 
	tmpfs:
			- ${1:dir}

# ===================
# Kubernetes snippets
# ===================
snippet k-configmap k8s ConfigMap
	# https://kubernetes.io/docs/concepts/configuration/configmap/
	kind: ConfigMap
	apiVersion: v1
	metadata:
	  name: ${1:myconfig}
	  namespace: ${2:default}
	data:
	  ${3:key}: ${4:value}
	---
	$0
snippet k-cronjob k8s CronJob
	# https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/
	apiVersion: batch/v1beta1
	kind: CronJob
	metadata:
	  name: ${1:cronjobname}
	  namespace: ${2:default}
	spec:
	  schedule: "${3:*/1 * * * *}"
	  jobTemplate:
	    spec:
	      template:
	        spec:
	          containers:
	          - name: ${4:jobname}
	            image: ${5:busybox}
	            args: ['/bin/sh', '-c', '${6:date; echo Hello from the Kubernetes cluster}']
	          restartPolicy: OnFailure
	---
	$0
snippet k-daemonset k8s DaemonSet
	# https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
	apiVersion: apps/v1
	kind: DaemonSet
	metadata:
	  name: ${1:myapp}
	  namespace: ${2:default}
	  labels:
	    app: ${1:myapp}
	spec:
	  selector:
	    matchLabels:
	      app: ${1:myapp}
	  template:
	    metadata:
	      labels:
	        app: ${1:myapp}
	    spec:
	      tolerations:
	      # this toleration is to have the daemonset runnable on master nodes
	      # remove it if your masters can't run pods
	      - key: node-role.kubernetes.io/master
	        effect: NoSchedule
	      containers:
	      - name: ${1:myapp}
	        image: ${3:debian}
	        resources:
	          limits:
	            memory: 200Mi
	          requests:
	            cpu: 100m
	            memory: 200Mi
	        volumeMounts:
	        - name: localtime
	          mountPath: /etc/localtime
	      terminationGracePeriodSeconds: 30
	      volumes:
	      - name: localtime
	        hostPath:
	          path: /usr/share/zoneinfo/Asia/Taipei
	---
	$0
snippet k-deployment k8s Deployment
	# https://kubernetes.io/docs/concepts/workloads/controllers/deployment/
	apiVersion: apps/v1
	kind: Deployment
	metadata:
	  name:  ${1:myjob}
	  namespace: ${2:default}
	  labels:
	    app:  ${1:myjob}
	spec:
	  selector:
	    matchLabels:
	      app: ${1:myjob}
	  replicas: 1
	  strategy:
	    rollingUpdate:
	      maxSurge: 25%
	      maxUnavailable: 25%
	    type: RollingUpdate
	  template:
	    metadata:
	      labels:
	        app:  ${1:myjob}
	    spec:
	      # initContainers:
	        # Init containers are exactly like regular containers, except:
	          # - Init containers always run to completion.
	          # - Each init container must complete successfully before the next one starts.
	      containers:
	      - name:  ${1:myjob}
	        image:  ${3:myjob:latest}
	        imagePullPolicy: ${4|IfNotPresent,Always,Never|}
	        resources:
	          requests:
	            cpu: 100m
	            memory: 100Mi
	          limits:
	            cpu: 100m
	            memory: 100Mi
	        livenessProbe:
	          tcpSocket:
	            port: ${5:80}
	          initialDelaySeconds: 5
	          timeoutSeconds: 5
	          successThreshold: 1
	          failureThreshold: 3
	          periodSeconds: 10
	        readinessProbe:
	          httpGet:
	            path: /_status/healthz
	            port: ${5:80}
	          initialDelaySeconds: 5
	          timeoutSeconds: 2
	          successThreshold: 1
	          failureThreshold: 3
	          periodSeconds: 10
	        env:
	        - name: DB_HOST
	          valueFrom:
	            configMapKeyRef:
	              name: ${1:myjob}
	              key: DB_HOST
	        ports:
	        - containerPort:  ${5:80}
	          name:  ${1:myjob}
	        volumeMounts:
	        - name: localtime
	          mountPath: /etc/localtime
	      volumes:
	        - name: localtime
	          hostPath:
	            path: /usr/share/zoneinfo/Asia/Taipei
	      restartPolicy: Always
	---
	$0
snippet k-ingress k8s Ingress
	# https://kubernetes.io/docs/concepts/services-networking/ingress/
	apiVersion: networking.k8s.io/v1
	kind: Ingress
	metadata:
	  name: ${1:example-ingress}
	  namespace: ${2:default}
	spec:
	  rules:
	  - host: ${3:example.foo.com}
	    http:
	      paths:
	      - path: /$4
	        pathType: ${5|Prefix,Exact|}
	        backend:
	          service:
	            name: ${6:service1}
	            port:
	              number: ${7:80}
	---
	$0
snippet k-ingress-rewrite k8s Ingress with Rewrite rule
	# https://kubernetes.io/docs/concepts/services-networking/ingress/
	apiVersion: networking.k8s.io/v1
	kind: Ingress
	metadata:
	  name: ${1:example-ingress}
	  namespace: ${2:default}
	  # https://kubernetes.github.io/ingress-nginx/examples/rewrite/
	  annotations:
	    nginx.ingress.kubernetes.io/rewrite-target: /\$1
	spec:
	  rules:
	  - host: ${3:example.foo.com}
	    http:
	      paths:
	      - path: ${4:/api/(.*)}
	        pathType: Prefix
	        backend:
	          service:
	            name: ${5:service1}
	            port:
	              number: ${6:80}
	---
	$0
snippet k-ingress-tls k8s Ingress with TLS
	# https://kubernetes.io/docs/concepts/services-networking/ingress/#tls
	apiVersion: v1
	kind: Secret
	metadata:
	  name: ${1:testsecret-tls}
	  namespace: ${2:default}
	type: kubernetes.io/tls
	# The TLS secret must contain keys named 'tls.crt' and 'tls.key' that contain the certificate and private key to use for TLS.
	data:
	  tls.crt: base64 encoded cert
	  tls.key: base64 encoded key
	
	---
	apiVersion: networking.k8s.io/v1
	kind: Ingress
	metadata:
	  name: ${3:tls-example-ingress}
	  namespace: ${2:default}
	spec:
	  tls:
	  - hosts:
	      - ${4:https-example.foo.com}
	    secretName: ${1:testsecret-tls}
	  rules:
	  - host: ${4:https-example.foo.com}
	    http:
	      paths:
	      - path: /$5
	        pathType: Prefix
	        backend:
	          service:
	            name: ${6:service1}
	            port:
	              number: ${7:80}
	---
	$0
snippet k-job k8s Job
	# https://kubernetes.io/docs/concepts/workloads/controllers/job/
	apiVersion: batch/v1
	kind: Job
	metadata:
	  name: ${1:myjob}
	  namespace: ${2:default}
	  labels:
	    app: ${1:myjob}
	spec:
	  template:
	    metadata:
	      name: ${1:myjob}
	      labels:
	        app: ${1:myjob}
	    spec:
	      containers:
	      - name: ${1:myjob}
	        image: ${3:python:3.7.6-alpine3.10}
	        command: ['sh', '-c', '${4:python3 manage.py makemigrations && python3 manage.py migrate}']
	        env:
	        - name: ENV_NAME
	          value: ENV_VALUE
	        volumeMounts:
	        - name: localtime
	          mountPath: /etc/localtime
	      volumes:
	      - name: localtime
	        hostPath:
	          path: /usr/share/zoneinfo/Asia/Taipei
	      restartPolicy: OnFailure
	      dnsPolicy: ClusterFirst
	---
	$0
snippet k-pvc k8s PersistentVolumeClaim
	# https://kubernetes.io/docs/concepts/storage/persistent-volumes/
	apiVersion: v1
	kind: PersistentVolumeClaim
	metadata:
	  name: ${1:myapp}
	  namespace: ${2:default}
	  labels:
	    app: ${1:myapp}
	spec:
	  # AKS: default,managed-premium
	  # GKE: standard
	  # EKS: gp2 (custom)
	  # Rook: rook-ceph-block,rook-ceph-fs
	  storageClassName: ${3|default,managed-premium,standard,gp2,rook-ceph-block,rook-ceph-fs|}
	  accessModes:
	  - ${4|ReadWriteOnce,ReadWriteMany,ReadOnlyMany|}
	  resources:
	    requests:
	      storage: ${5:2Gi}
	---
	$0
snippet k-pod k8s Pod
	# https://kubernetes.io/docs/concepts/workloads/pods/
	apiVersion: v1
	kind: Pod
	metadata:
	  name: "${1:myapp}"
	  namespace: ${2:default}
	  labels:
	    app: "${1:myapp}"
	spec:
	  containers:
	  - name: ${1:myapp}
	    image: "${3:debian-slim:latest}"
	    resources:
	      limits:
	        cpu: 200m
	        memory: 500Mi
	      requests:
	        cpu: 100m
	        memory: 200Mi
	    env:
	    - name: DB_HOST
	      valueFrom:
	        configMapKeyRef:
	          name: myapp
	          key: DB_HOST
	    ports:
	    - containerPort: ${4:80}
	      name:  http
	    volumeMounts:
	    - name: localtime
	      mountPath: /etc/localtime
	  volumes:
	    - name: localtime
	      hostPath:
	        path: /usr/share/zoneinfo/Asia/Taipei
	  restartPolicy: Always
	---
	$0
snippet k-secret k8s Secret
	# https://kubernetes.io/docs/concepts/configuration/secret/
	apiVersion: v1
	kind: Secret
	metadata:
	  name: ${1:mysecret}
	  namespace: ${2:default}
	type: Opaque
	data:
	  # Example:
	  # password: {{ .Values.password | b64enc }}
	---
	$0
snippet k-service k8s Service
	# https://kubernetes.io/docs/concepts/services-networking/service/
	apiVersion: v1
	kind: Service
	metadata:
	  name: ${1:myjob}
	  namespace: ${2:default}
	spec:
	  selector:
	    app: ${1:myjob}
	  type: ${3|ClusterIP,NodePort,LoadBalancer|}
	  ports:
	  - name: ${1:myjob}
	    protocol: ${4|TCP,UDP|}
	    port: ${5:80}
	    targetPort: ${6:5000}
	    nodePort: ${7:30001}
	---
	$0
snippet k-statefulset k8s StatefulSet
	# https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/
	apiVersion: apps/v1
	kind: StatefulSet
	metadata:
	  name: ${1:myapp}
	  namespace: ${2:default}
	spec:
	  selector:
	    matchLabels:
	      app: ${1:myapp} # has to match .spec.template.metadata.labels
	  serviceName: "${1:myapp}"
	  replicas: ${3:3} # by default is 1
	  template:
	    metadata:
	      labels:
	        app: ${1:myapp} # has to match .spec.selector.matchLabels
	    spec:
	      terminationGracePeriodSeconds: 10
	      containers:
	      - name: ${1:myapp}
	        image: ${4:${1:myapp}-slim:1.16.1}
	        ports:
	        - containerPort: ${5:80}
	          name: ${1:myapp}
	        volumeMounts:
	        - name: ${6:www}
	          mountPath: /usr/share/nginx/html
	  volumeClaimTemplates:
	  - metadata:
	      name: ${6:www}
	    spec:
	      storageClassName: ${7:my-storage-class}
	      accessModes:
	      - ${8|ReadWriteOnce,ReadWriteMany,ReadOnlyMany|}
	      resources:
	        requests:
	          storage: ${9:1Gi}
	---
	$0
