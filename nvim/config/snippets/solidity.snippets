# Generated by snippet-converter.nvim (https://github.com/smjonas/snippet-converter.nvim)

snippet const
	constructor (${1:type} ${2:name}) public {
		$0
	}
snippet con
	contract ${1:Name} {
		$0
	}
snippet enum
	enum ${1:Name} {${2:item1}, ${3:item2} }
snippet erc1155i EIP-1155: ERC-1155 Multi Token Standard, A standard interface for contracts that manage multiple token types. A single deployed contract may include any combination of fungible tokens, non-fungible tokens or other configurations (e.g. semi-fungible tokens).
	// https://eips.ethereum.org/EIPS/eip-1155
	// Example implementation https://github.com/enjin/erc-1155/blob/master/contracts/ERC1155.sol
	// SPDX-License-Identifier: MIT
	pragma solidity >=0.5.0 <0.8.0;
	
	/**
	    @title ERC-1155 Multi Token Standard
	    @dev See https://eips.ethereum.org/EIPS/eip-1155
	    Note: The ERC-165 identifier for this interface is 0xd9b67a26.
	 */
	interface ERC1155 /* is ERC165 */ {
	    /**
	        @dev Either \`TransferSingle\` or \`TransferBatch\` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see "Safe Transfer Rules" section of the standard).
	        The \`_operator\` argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender).
	        The \`_from\` argument MUST be the address of the holder whose balance is decreased.
	        The \`_to\` argument MUST be the address of the recipient whose balance is increased.
	        The \`_id\` argument MUST be the token type being transferred.
	        The \`_value\` argument MUST be the number of tokens the holder balance is decreased by and match what the recipient balance is increased by.
	        When minting/creating tokens, the \`_from\` argument MUST be set to \`0x0\` (i.e. zero address).
	        When burning/destroying tokens, the \`_to\` argument MUST be set to \`0x0\` (i.e. zero address).
	    */
	    event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _value);
	
	    /**
	        @dev Either \`TransferSingle\` or \`TransferBatch\` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see "Safe Transfer Rules" section of the standard).
	        The \`_operator\` argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender).
	        The \`_from\` argument MUST be the address of the holder whose balance is decreased.
	        The \`_to\` argument MUST be the address of the recipient whose balance is increased.
	        The \`_ids\` argument MUST be the list of tokens being transferred.
	        The \`_values\` argument MUST be the list of number of tokens (matching the list and order of tokens specified in _ids) the holder balance is decreased by and match what the recipient balance is increased by.
	        When minting/creating tokens, the \`_from\` argument MUST be set to \`0x0\` (i.e. zero address).
	        When burning/destroying tokens, the \`_to\` argument MUST be set to \`0x0\` (i.e. zero address).
	    */
	    event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _values);
	
	    /**
	        @dev MUST emit when approval for a second party/operator address to manage all tokens for an owner address is enabled or disabled (absence of an event assumes disabled).
	    */
	    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);
	
	    /**
	        @dev MUST emit when the URI is updated for a token ID.
	        URIs are defined in RFC 3986.
	        The URI MUST point to a JSON file that conforms to the "ERC-1155 Metadata URI JSON Schema".
	    */
	    event URI(string _value, uint256 indexed _id);
	
	    /**
	        @notice Transfers \`_value\` amount of an \`_id\` from the \`_from\` address to the \`_to\` address specified (with safety call).
	        @dev Caller must be approved to manage the tokens being transferred out of the \`_from\` account (see "Approval" section of the standard).
	        MUST revert if \`_to\` is the zero address.
	        MUST revert if balance of holder for token \`_id\` is lower than the \`_value\` sent.
	        MUST revert on any other error.
	        MUST emit the \`TransferSingle\` event to reflect the balance change (see "Safe Transfer Rules" section of the standard).
	        After the above conditions are met, this function MUST check if \`_to\` is a smart contract (e.g. code size > 0). If so, it MUST call \`onERC1155Received\` on \`_to\` and act appropriately (see "Safe Transfer Rules" section of the standard).
	        @param _from    Source address
	        @param _to      Target address
	        @param _id      ID of the token type
	        @param _value   Transfer amount
	        @param _data    Additional data with no specified format, MUST be sent unaltered in call to \`onERC1155Received\` on \`_to\`
	    */
	    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external;
	
	    /**
	        @notice Transfers \`_values\` amount(s) of \`_ids\` from the \`_from\` address to the \`_to\` address specified (with safety call).
	        @dev Caller must be approved to manage the tokens being transferred out of the \`_from\` account (see "Approval" section of the standard).
	        MUST revert if \`_to\` is the zero address.
	        MUST revert if length of \`_ids\` is not the same as length of \`_values\`.
	        MUST revert if any of the balance(s) of the holder(s) for token(s) in \`_ids\` is lower than the respective amount(s) in \`_values\` sent to the recipient.
	        MUST revert on any other error.
	        MUST emit \`TransferSingle\` or \`TransferBatch\` event(s) such that all the balance changes are reflected (see "Safe Transfer Rules" section of the standard).
	        Balance changes and events MUST follow the ordering of the arrays (_ids[0]/_values[0] before _ids[1]/_values[1], etc).
	        After the above conditions for the transfer(s) in the batch are met, this function MUST check if \`_to\` is a smart contract (e.g. code size > 0). If so, it MUST call the relevant \`ERC1155TokenReceiver\` hook(s) on \`_to\` and act appropriately (see "Safe Transfer Rules" section of the standard).
	        @param _from    Source address
	        @param _to      Target address
	        @param _ids     IDs of each token type (order and length must match _values array)
	        @param _values  Transfer amounts per token type (order and length must match _ids array)
	        @param _data    Additional data with no specified format, MUST be sent unaltered in call to the \`ERC1155TokenReceiver\` hook(s) on \`_to\`
	    */
	    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids,
	                                    uint256[] calldata _values, bytes calldata _data) external;
	
	    /**
	        @notice Get the balance of an account's tokens.
	        @param _owner  The address of the token holder
	        @param _id     ID of the token
	        @return        The _owner's balance of the token type requested
	     */
	    function balanceOf(address _owner, uint256 _id) external view returns (uint256);
	
	    /**
	        @notice Get the balance of multiple account/token pairs
	        @param _owners The addresses of the token holders
	        @param _ids    ID of the tokens
	        @return        The _owner's balance of the token types requested (i.e. balance for each (owner, id) pair)
	     */
	    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);
	
	    /**
	        @notice Enable or disable approval for a third party ("operator") to manage all of the caller's tokens.
	        @dev MUST emit the ApprovalForAll event on success.
	        @param _operator  Address to add to the set of authorized operators
	        @param _approved  True if the operator is approved, false to revoke approval
	    */
	    function setApprovalForAll(address _operator, bool _approved) external;
	
	    /**
	        @notice Queries the approval status of an operator for a given owner.
	        @param _owner     The owner of the tokens
	        @param _operator  Address of authorized operator
	        @return           True if the operator is approved, false if not
	    */
	    function isApprovedForAll(address _owner, address _operator) external view returns (bool);
	}
	
	/* ERC-1155 Token Receiver
	Smart contracts MUST implement all of the functions in the ERC1155TokenReceiver interface to accept transfers. See “Safe Transfer Rules” for further detail.
	
	Smart contracts MUST implement the ERC-165 supportsInterface function and signify support for the ERC1155TokenReceiver interface to accept transfers. See “ERC1155TokenReceiver ERC-165 rules” for further detail.
	
	/**
	    Note: The ERC-165 identifier for this interface is 0x4e2312e0.
	*/
	interface ERC1155TokenReceiver {
	    /**
	        @notice Handle the receipt of a single ERC1155 token type.
	        @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a \`safeTransferFrom\` after the balance has been updated.
	        This function MUST return \`bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))\` (i.e. 0xf23a6e61) if it accepts the transfer.
	        This function MUST revert if it rejects the transfer.
	        Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.
	        @param _operator  The address which initiated the transfer (i.e. msg.sender)
	        @param _from      The address which previously owned the token
	        @param _id        The ID of the token being transferred
	        @param _value     The amount of tokens being transferred
	        @param _data      Additional data with no specified format
	        @return           \`bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))\`
	    */
	    function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _value, bytes calldata _data) external returns(bytes4);
	
	    /**
	        @notice Handle the receipt of multiple ERC1155 token types.
	        @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a \`safeBatchTransferFrom\` after the balances have been updated.
	        This function MUST return \`bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))\` (i.e. 0xbc197c81) if it accepts the transfer(s).
	        This function MUST revert if it rejects the transfer(s).
	        Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.
	        @param _operator  The address which initiated the batch transfer (i.e. msg.sender)
	        @param _from      The address which previously owned the token
	        @param _ids       An array containing ids of each token being transferred (order and length must match _values array)
	        @param _values    An array containing amounts of each token being transferred (order and length must match _ids array)
	        @param _data      Additional data with no specified format
	        @return           \`bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))\`
	    */
	    function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids,
	                                        uint256[] calldata _values, bytes calldata _data) external returns(bytes4);
	}
snippet erc165i ERC165 Standard Interface Detection Interface: Creates a standard method to publish and detect what interfaces a smart contract implements.
	// https://eips.ethereum.org/EIPS/eip-165 
	// SPDX-License-Identifier: MIT
	pragma solidity >=0.5.0 <0.8.0;
	interface ERC165 {
	    /// @notice Query if a contract implements an interface
	    /// @param interfaceID The interface identifier, as specified in ERC-165
	    /// @dev Interface identification is specified in ERC-165. This function
	    ///  uses less than 30,000 gas.
	    /// @return \`true\` if the contract implements \`interfaceID\` and
	    ///  \`interfaceID\` is not 0xffffffff, \`false\` otherwise
	    function supportsInterface(bytes4 interfaceID) external view returns (bool);
	}
snippet erc173-draft Draft: EIP-173: Implementation example, Contract Ownership Standard, A standard interface for ownership of contracts.
	// https://eips.ethereum.org/EIPS/eip-173
	// https://github.com/0xcert/ethereum-erc721/blob/master/src/contracts/ownership/ownable.sol (this example)
	// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol
	// https://github.com/FriendlyUser/solidity-smart-contracts//blob/v0.2.0/contracts/other/CredVert/Ownable.sol
	// SPDX-License-Identifier: MIT
	pragma solidity >=0.5.0 <0.8.0;
	
	/**
	 * @dev The contract has an owner address, and provides basic authorization control whitch
	 * simplifies the implementation of user permissions. This contract is based on the source code at:
	 * https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ownership/Ownable.sol
	 */
	contract Ownable
	{
	
	  /**
	   * @dev Error constants.
	   */
	  string public constant NOT_CURRENT_OWNER = "018001";
	  string public constant CANNOT_TRANSFER_TO_ZERO_ADDRESS = "018002";
	
	  /**
	   * @dev Current owner address.
	   */
	  address public owner;
	
	  /**
	   * @dev An event which is triggered when the owner is changed.
	   * @param previousOwner The address of the previous owner.
	   * @param newOwner The address of the new owner.
	   */
	  event OwnershipTransferred(
	    address indexed previousOwner,
	    address indexed newOwner
	  );
	
	  /**
	   * @dev The constructor sets the original \`owner\` of the contract to the sender account.
	   */
	  constructor()
	    public
	  {
	    owner = msg.sender;
	  }
	
	  /**
	   * @dev Throws if called by any account other than the owner.
	   */
	  modifier onlyOwner()
	  {
	    require(msg.sender == owner, NOT_CURRENT_OWNER);
	    _;
	  }
	
	  /**
	   * @dev Allows the current owner to transfer control of the contract to a newOwner.
	   * @param _newOwner The address to transfer ownership to.
	   */
	  function transferOwnership(
	    address _newOwner
	  )
	    public
	    onlyOwner
	  {
	    require(_newOwner != address(0), CANNOT_TRANSFER_TO_ZERO_ADDRESS);
	    emit OwnershipTransferred(owner, _newOwner);
	    owner = _newOwner;
	  }
	
	}
snippet erc173i-draft Draft: EIP-173 Interface for Contract Ownership Standard, A standard interface for ownership of contracts.
	// https://eips.ethereum.org/EIPS/eip-173
	// https://github.com/0xcert/ethereum-erc721/blob/master/src/contracts/ownership/ownable.sol (this example)
	// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol
	// https://github.com/FriendlyUser/solidity-smart-contracts//blob/v0.2.0/contracts/other/CredVert/Ownable.sol
	// SPDX-License-Identifier: MIT
	pragma solidity >=0.5.0 <0.8.0;
	
	/// @title ERC-173 Contract Ownership Standard
	/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-173.md
	///  Note: the ERC-165 identifier for this interface is 0x7f5828d0
	interface ERC173 /* is ERC165 */ {
	    /// @dev This emits when ownership of a contract changes
	    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
	
	    /// @notice Get the address of the owner
	    /// @return The address of the owner.
	    function owner() external view returns (address);
	    /// @notice Set the address of the new owner of the contract
	    /// @dev Set _newOwner to address(0) to renounce any ownership.
	    /// @param _newOwner The address of the new owner of the contract
	    function transferOwnership(address _newOwner) external;
	}
	
	interface ERC165 {
	    /// @notice Query if a contract implements an interface
	    /// @param interfaceID The interface identifier, as specified in ERC-165
	    /// @dev Interface identification is specified in ERC-165. This function
	    ///  uses less than 30,000 gas.
	    /// @return \`true\` if the contract implements \`interfaceID\` and
	    ///  \`interfaceID\` is not 0xffffffff, \`false\` otherwise
	    function supportsInterface(bytes4 interfaceID) external view returns (bool);
	}
snippet erc1820 EIP-1820: Pseudo-introspection Registry Contract, This standard defines a universal registry smart contract where any address (contract or regular account) can register which interface it supports and which smart contract is responsible for its implementation.
	// https://eips.ethereum.org/EIPS/eip-1820
	// SPDX-License-Identifier: MIT
	pragma solidity >=0.5.0 <0.8.0;
	/* ERC1820 Pseudo-introspection Registry Contract
	 * This standard defines a universal registry smart contract where any address (contract or regular account) can
	 * register which interface it supports and which smart contract is responsible for its implementation.
	 *
	 * Written in 2019 by Jordi Baylina and Jacques Dafflon
	 *
	 * To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to
	 * this software to the public domain worldwide. This software is distributed without any warranty.
	 *
	 * You should have received a copy of the CC0 Public Domain Dedication along with this software. If not, see
	 * <http://creativecommons.org/publicdomain/zero/1.0/>.
	 *
	 *    ███████╗██████╗  ██████╗ ██╗ █████╗ ██████╗  ██████╗
	 *    ██╔════╝██╔══██╗██╔════╝███║██╔══██╗╚════██╗██╔═████╗
	 *    █████╗  ██████╔╝██║     ╚██║╚█████╔╝ █████╔╝██║██╔██║
	 *    ██╔══╝  ██╔══██╗██║      ██║██╔══██╗██╔═══╝ ████╔╝██║
	 *    ███████╗██║  ██║╚██████╗ ██║╚█████╔╝███████╗╚██████╔╝
	 *    ╚══════╝╚═╝  ╚═╝ ╚═════╝ ╚═╝ ╚════╝ ╚══════╝ ╚═════╝
	 *
	 *    ██████╗ ███████╗ ██████╗ ██╗███████╗████████╗██████╗ ██╗   ██╗
	 *    ██╔══██╗██╔════╝██╔════╝ ██║██╔════╝╚══██╔══╝██╔══██╗╚██╗ ██╔╝
	 *    ██████╔╝█████╗  ██║  ███╗██║███████╗   ██║   ██████╔╝ ╚████╔╝
	 *    ██╔══██╗██╔══╝  ██║   ██║██║╚════██║   ██║   ██╔══██╗  ╚██╔╝
	 *    ██║  ██║███████╗╚██████╔╝██║███████║   ██║   ██║  ██║   ██║
	 *    ╚═╝  ╚═╝╚══════╝ ╚═════╝ ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝   ╚═╝
	 *
	 */
	// IV is value needed to have a vanity address starting with '0x1820'.
	// IV: 53759
	
	/// @dev The interface a contract MUST implement if it is the implementer of
	/// some (other) interface for any address other than itself.
	interface ERC1820ImplementerInterface {
	    /// @notice Indicates whether the contract implements the interface 'interfaceHash' for the address 'addr' or not.
	    /// @param interfaceHash keccak256 hash of the name of the interface
	    /// @param addr Address for which the contract will implement the interface
	    /// @return ERC1820_ACCEPT_MAGIC only if the contract implements 'interfaceHash' for the address 'addr'.
	    function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) external view returns(bytes32);
	}
	
	
	/// @title ERC1820 Pseudo-introspection Registry Contract
	/// @author Jordi Baylina and Jacques Dafflon
	/// @notice This contract is the official implementation of the ERC1820 Registry.
	/// @notice For more details, see https://eips.ethereum.org/EIPS/eip-1820
	contract ERC1820Registry {
	    ///@dev @notice ERC165 Invalid ID.
	    bytes4 constant internal INVALID_ID = 0xffffffff;
	    ///@dev @notice Method ID for the ERC165 supportsInterface method (= \`bytes4(keccak256('supportsInterface(bytes4)'))\`).
	    bytes4 constant internal ERC165ID = 0x01ffc9a7;
	    ///@dev @notice Magic value which is returned if a contract implements an interface on behalf of some other address.
	    bytes32 constant internal ERC1820_ACCEPT_MAGIC = keccak256(abi.encodePacked("ERC1820_ACCEPT_MAGIC"));
	
	    ///@dev @notice mapping from addresses and interface hashes to their implementers.
	    mapping(address => mapping(bytes32 => address)) internal interfaces;
	    ///@dev @notice mapping from addresses to their manager.
	    mapping(address => address) internal managers;
	    ///@dev @notice flag for each address and erc165 interface to indicate if it is cached.
	    mapping(address => mapping(bytes4 => bool)) internal erc165Cached;
	
	    /// @notice Indicates a contract is the 'implementer' of 'interfaceHash' for 'addr'.
	    event InterfaceImplementerSet(address indexed addr, bytes32 indexed interfaceHash, address indexed implementer);
	    /// @notice Indicates 'newManager' is the address of the new manager for 'addr'.
	    event ManagerChanged(address indexed addr, address indexed newManager);
	
	    /// @notice Query if an address implements an interface and through which contract.
	    /// @param _addr Address being queried for the implementer of an interface.
	    /// (If '_addr' is the zero address then 'msg.sender' is assumed.)
	    /// @param _interfaceHash Keccak256 hash of the name of the interface as a string.
	    /// E.g., 'web3.utils.keccak256("ERC777TokensRecipient")' for the 'ERC777TokensRecipient' interface.
	    /// @return The address of the contract which implements the interface '_interfaceHash' for '_addr'
	    /// or '0' if '_addr' did not register an implementer for this interface.
	    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address) {
	        address addr = _addr == address(0) ? msg.sender : _addr;
	        if (isERC165Interface(_interfaceHash)) {
	            bytes4 erc165InterfaceHash = bytes4(_interfaceHash);
	            return implementsERC165Interface(addr, erc165InterfaceHash) ? addr : address(0);
	        }
	        return interfaces[addr][_interfaceHash];
	    }
	
	    /// @notice Sets the contract which implements a specific interface for an address.
	    /// Only the manager defined for that address can set it.
	    /// (Each address is the manager for itself until it sets a new manager.)
	    /// @param _addr Address for which to set the interface.
	    /// (If '_addr' is the zero address then 'msg.sender' is assumed.)
	    /// @param _interfaceHash Keccak256 hash of the name of the interface as a string.
	    /// E.g., 'web3.utils.keccak256("ERC777TokensRecipient")' for the 'ERC777TokensRecipient' interface.
	    /// @param _implementer Contract address implementing '_interfaceHash' for '_addr'.
	    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external {
	        address addr = _addr == address(0) ? msg.sender : _addr;
	        require(getManager(addr) == msg.sender, "Not the manager");
	
	        require(!isERC165Interface(_interfaceHash), "Must not be an ERC165 hash");
	        if (_implementer != address(0) && _implementer != msg.sender) {
	            require(
	                ERC1820ImplementerInterface(_implementer)
	                    .canImplementInterfaceForAddress(_interfaceHash, addr) == ERC1820_ACCEPT_MAGIC,
	                "Does not implement the interface"
	            );
	        }
	        interfaces[addr][_interfaceHash] = _implementer;
	        emit InterfaceImplementerSet(addr, _interfaceHash, _implementer);
	    }
	
	    /// @notice Sets '_newManager' as manager for '_addr'.
	    /// The new manager will be able to call 'setInterfaceImplementer' for '_addr'.
	    /// @param _addr Address for which to set the new manager.
	    /// @param _newManager Address of the new manager for 'addr'. (Pass '0x0' to reset the manager to '_addr'.)
	    function setManager(address _addr, address _newManager) external {
	        require(getManager(_addr) == msg.sender, "Not the manager");
	        managers[_addr] = _newManager == _addr ? address(0) : _newManager;
	        emit ManagerChanged(_addr, _newManager);
	    }
	
	    /// @notice Get the manager of an address.
	    /// @param _addr Address for which to return the manager.
	    /// @return Address of the manager for a given address.
	    function getManager(address _addr) public view returns(address) {
	        // By default the manager of an address is the same address
	        if (managers[_addr] == address(0)) {
	            return _addr;
	        } else {
	            return managers[_addr];
	        }
	    }
	
	    /// @notice Compute the keccak256 hash of an interface given its name.
	    /// @param _interfaceName Name of the interface.
	    /// @return The keccak256 hash of an interface name.
	    function interfaceHash(string calldata _interfaceName) external pure returns(bytes32) {
	        return keccak256(abi.encodePacked(_interfaceName));
	    }
	
	    /* --- ERC165 Related Functions --- */
	    /* --- Developed in collaboration with William Entriken. --- */
	
	    /// @notice Updates the cache with whether the contract implements an ERC165 interface or not.
	    /// @param _contract Address of the contract for which to update the cache.
	    /// @param _interfaceId ERC165 interface for which to update the cache.
	    function updateERC165Cache(address _contract, bytes4 _interfaceId) external {
	        interfaces[_contract][_interfaceId] = implementsERC165InterfaceNoCache(
	            _contract, _interfaceId) ? _contract : address(0);
	        erc165Cached[_contract][_interfaceId] = true;
	    }
	
	    /// @notice Checks whether a contract implements an ERC165 interface or not.
	    //  If the result is not cached a direct lookup on the contract address is performed.
	    //  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling
	    //  'updateERC165Cache' with the contract address.
	    /// @param _contract Address of the contract to check.
	    /// @param _interfaceId ERC165 interface to check.
	    /// @return True if '_contract' implements '_interfaceId', false otherwise.
	    function implementsERC165Interface(address _contract, bytes4 _interfaceId) public view returns (bool) {
	        if (!erc165Cached[_contract][_interfaceId]) {
	            return implementsERC165InterfaceNoCache(_contract, _interfaceId);
	        }
	        return interfaces[_contract][_interfaceId] == _contract;
	    }
	
	    /// @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.
	    /// @param _contract Address of the contract to check.
	    /// @param _interfaceId ERC165 interface to check.
	    /// @return True if '_contract' implements '_interfaceId', false otherwise.
	    function implementsERC165InterfaceNoCache(address _contract, bytes4 _interfaceId) public view returns (bool) {
	        uint256 success;
	        uint256 result;
	
	        (success, result) = noThrowCall(_contract, ERC165ID);
	        if (success == 0 || result == 0) {
	            return false;
	        }
	
	        (success, result) = noThrowCall(_contract, INVALID_ID);
	        if (success == 0 || result != 0) {
	            return false;
	        }
	
	        (success, result) = noThrowCall(_contract, _interfaceId);
	        if (success == 1 && result == 1) {
	            return true;
	        }
	        return false;
	    }
	
	    /// @notice Checks whether the hash is a ERC165 interface (ending with 28 zeroes) or not.
	    /// @param _interfaceHash The hash to check.
	    /// @return True if '_interfaceHash' is an ERC165 interface (ending with 28 zeroes), false otherwise.
	    function isERC165Interface(bytes32 _interfaceHash) internal pure returns (bool) {
	        return _interfaceHash & 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0;
	    }
	
	    /// @dev Make a call on a contract without throwing if the function does not exist.
	    function noThrowCall(address _contract, bytes4 _interfaceId)
	        internal view returns (uint256 success, uint256 result)
	    {
	        bytes4 erc165ID = ERC165ID;
	
	        assembly {
	            let x := mload(0x40)               // Find empty storage location using "free memory pointer"
	            mstore(x, erc165ID)                // Place signature at beginning of empty storage
	            mstore(add(x, 0x04), _interfaceId) // Place first argument directly next to signature
	
	            success := staticcall(
	                30000,                         // 30k gas
	                _contract,                     // To addr
	                x,                             // Inputs are stored at location x
	                0x24,                          // Inputs are 36 (4 + 32) bytes long
	                x,                             // Store output over input (saves space)
	                0x20                           // Outputs are 32 bytes long
	            )
	
	            result := mload(x)                 // Load the result
	        }
	    }
	},
snippet erc1996i-draft Draft: EIP-1996: Holdable Token, An extension to the ERC-20 standard token that allows tokens to be put on hold. This guarantees a future transfer and makes the held tokens unavailable for transfer in the mean time. Holds are similar to escrows in that are firm and lead to final settlement.
	// https://eips.ethereum.org/EIPS/eip-1996
	// https://github.com/IoBuilders/holdable-token (example)
	// SPDX-License-Identifier: MIT
	/*
	An extension to the ERC-20 standard token that allows tokens to be put on hold.
	This guarantees a future transfer and makes the held tokens unavailable for transfer in the mean time.
	Holds are similar to escrows in that are firm and lead to final settlement.
	*/
	pragma solidity >=0.5.0 <0.8.0;
	
	interface IHoldable /* is ERC-20 */ {
	    enum HoldStatusCode {
	        Nonexistent,
	        Ordered,
	        Executed,
	        ReleasedByNotary,
	        ReleasedByPayee,
	        ReleasedOnExpiration
	    }
	
	    function hold(string calldata operationId, address to, address notary, uint256 value, uint256 timeToExpiration) external returns (bool);
	    function holdFrom(string calldata operationId, address from, address to, address notary,
	                                                     uint256 value, uint256 timeToExpiration) external returns (bool);
	    function releaseHold(string calldata operationId) external returns (bool);
	    function executeHold(string calldata operationId, uint256 value) external returns (bool);
	    function renewHold(string calldata operationId, uint256 timeToExpiration) external returns (bool);
	    function retrieveHoldData(string calldata operationId) external view returns (address from, address to, address notary,
	                                                                                uint256 value, uint256 expiration, HoldStatusCode status);
	
	    function balanceOnHold(address account) external view returns (uint256);
	    function netBalanceOf(address account) external view returns (uint256);
	    function totalSupplyOnHold() external view returns (uint256);
	
	    function authorizeHoldOperator(address operator) external returns (bool);
	    function revokeHoldOperator(address operator) external returns (bool);
	    function isHoldOperatorFor(address operator, address from) external view returns (bool);
	
	    event HoldCreated(address indexed holdIssuer, string  operationId, address from,
	                                address to, address indexed notary, uint256 value, uint256 expiration);
	    event HoldExecuted(address indexed holdIssuer, string operationId, address indexed notary, uint256 heldValue, uint256 transferredValue);
	    event HoldReleased(address indexed holdIssuer, string operationId, HoldStatusCode status);
	    event HoldRenewed(address indexed holdIssuer, string operationId, uint256 oldExpiration, uint256 newExpiration);
	    event AuthorizedHoldOperator(address indexed operator, address indexed account);
	    event RevokedHoldOperator(address indexed operator, address indexed account);
	}
snippet erc20 ERC20 example implementation
	// https://eips.ethereum.org/EIPS/eip-20
	// SPDX-License-Identifier: MIT
	pragma solidity >=0.5.0 <0.8.0;
	
	interface Token {
	
	    /// @param _owner The address from which the balance will be retrieved
	    /// @return balance the balance
	    function balanceOf(address _owner) external view returns (uint256 balance);
	
	    /// @notice send \`_value\` token to \`_to\` from \`msg.sender\`
	    /// @param _to The address of the recipient
	    /// @param _value The amount of token to be transferred
	    /// @return success Whether the transfer was successful or not
	    function transfer(address _to, uint256 _value)  external returns (bool success);
	
	    /// @notice send \`_value\` token to \`_to\` from \`_from\` on the condition it is approved by \`_from\`
	    /// @param _from The address of the sender
	    /// @param _to The address of the recipient
	    /// @param _value The amount of token to be transferred
	    /// @return success Whether the transfer was successful or not
	    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
	
	    /// @notice \`msg.sender\` approves \`_addr\` to spend \`_value\` tokens
	    /// @param _spender The address of the account able to transfer the tokens
	    /// @param _value The amount of wei to be approved for transfer
	    /// @return success Whether the approval was successful or not
	    function approve(address _spender  , uint256 _value) external returns (bool success);
	
	    /// @param _owner The address of the account owning tokens
	    /// @param _spender The address of the account able to transfer the tokens
	    /// @return remaining Amount of remaining tokens allowed to spent
	    function allowance(address _owner, address _spender) external view returns (uint256 remaining);
	
	    event Transfer(address indexed _from, address indexed _to, uint256 _value);
	    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
	}
	
	contract Standard_Token is Token {
	    uint256 constant private MAX_UINT256 = 2**256 - 1;
	    mapping (address => uint256) public balances;
	    mapping (address => mapping (address => uint256)) public allowed;
	    uint256 public totalSupply;
	    /*
	    NOTE:
	    The following variables are OPTIONAL vanities. One does not have to include them.
	    They allow one to customise the token contract & in no way influences the core functionality.
	    Some wallets/interfaces might not even bother to look at this information.
	    */
	    string public name;                   //fancy name: eg Simon Bucks
	    uint8 public decimals;                //How many decimals to show.
	    string public symbol;                 //An identifier: eg SBX
	
	    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string  memory _tokenSymbol) {
	        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens
	        totalSupply = _initialAmount;                        // Update total supply
	        name = _tokenName;                                   // Set the name for display purposes
	        decimals = _decimalUnits;                            // Amount of decimals for display purposes
	        symbol = _tokenSymbol;                               // Set the symbol for display purposes
	    }
	
	    function transfer(address _to, uint256 _value) public override returns (bool success) {
	        require(balances[msg.sender] >= _value, "token balance is lower than the value requested");
	        balances[msg.sender] -= _value;
	        balances[_to] += _value;
	        emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars
	        return true;
	    }
	
	    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {
	        uint256 allowance = allowed[_from][msg.sender];
	        require(balances[_from] >= _value && allowance >= _value, "token balance or allowance is lower than amount requested");
	        balances[_to] += _value;
	        balances[_from] -= _value;
	        if (allowance < MAX_UINT256) {
	            allowed[_from][msg.sender] -= _value;
	        }
	        emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars
	        return true;
	    }
	
	    function balanceOf(address _owner) public override view returns (uint256 balance) {
	        return balances[_owner];
	    }
	
	    function approve(address _spender, uint256 _value) public override returns (bool success) {
	        allowed[msg.sender][_spender] = _value;
	        emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars
	        return true;
	    }
	
	    function allowance(address _owner, address _spender) public override view returns (uint256 remaining) {
	        return allowed[_owner][_spender];
	    }
	}
snippet erc20i ERC20 token standard interface
	// https://eips.ethereum.org/EIPS/eip-20
	// SPDX-License-Identifier: MIT
	pragma solidity >=0.5.0 <0.8.0;
	
	interface Token {
	
	    /// @param _owner The address from which the balance will be retrieved
	    /// @return balance the balance
	    function balanceOf(address _owner) external view returns (uint256 balance);
	
	    /// @notice send \`_value\` token to \`_to\` from \`msg.sender\`
	    /// @param _to The address of the recipient
	    /// @param _value The amount of token to be transferred
	    /// @return success Whether the transfer was successful or not
	    function transfer(address _to, uint256 _value) external returns (bool success);
	
	    /// @notice send \`_value\` token to \`_to\` from \`_from\` on the condition it is approved by \`_from\`
	    /// @param _from The address of the sender
	    /// @param _to The address of the recipient
	    /// @param _value The amount of token to be transferred
	    /// @return success Whether the transfer was successful or not
	    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
	
	    /// @notice \`msg.sender\` approves \`_addr\` to spend \`_value\` tokens
	    /// @param _spender The address of the account able to transfer the tokens
	    /// @param _value The amount of wei to be approved for transfer
	    /// @return success Whether the approval was successful or not
	    function approve(address _spender, uint256 _value) external returns (bool success);
	
	    /// @param _owner The address of the account owning tokens
	    /// @param _spender The address of the account able to transfer the tokens
	    /// @return remaining Amount of remaining tokens allowed to spent
	    function allowance(address _owner, address _spender) external view returns (uint256 remaining);
	
	    event Transfer(address indexed _from, address indexed _to, uint256 _value);
	    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
	}
snippet erc2018i-draft Draft: EIP-2018: The clearing process turns the promise of a transfer into the actual movement of money from one account to another. A clearing agent decides if the transfer can be executed or not. The amount which should be transferred is not deducted from the balance of the payer, but neither is it available for another transfer and therefore ensures, that the execution of the transfer will be successful when it is executed.
	// https://eips.ethereum.org/EIPS/eip-2018
	// https://github.com/IoBuilders/clearable-token (example)
	// SPDX-License-Identifier: MIT
	/*
	In banking and finance, clearing denotes all activities from the time a commitment is made for a transaction until it is settled
	
	The clearing process turns the promise of a transfer into the actual movement of money from one account to another.
	A clearing agent decides if the transfer can be executed or not.
	The amount which should be transferred is not deducted from the balance of the payer, but neither is it available for another transfer and therefore ensures,
	that the execution of the transfer will be successful when it is executed.
	*/
	pragma solidity >=0.5.0 <0.8.0;
	
	interface ClearableToken /* is ERC-1996 */ {
	    enum ClearableTransferStatusCode { Nonexistent, Ordered, InProcess, Executed, Rejected, Cancelled }
	
	    function orderTransfer(string calldata operationId, address to, uint256 value) external returns (bool);
	    function orderTransferFrom(string calldata operationId, address from, address to, uint256 value) external returns (bool);
	    function cancelTransfer(string calldata operationId) external returns (bool);
	    function processClearableTransfer(string calldata operationId) external returns (bool);
	    function executeClearableTransfer(string calldata operationId) external returns (bool);
	    function rejectClearableTransfer(string calldata operationId, string calldata reason) external returns (bool);
	    function retrieveClearableTransferData(string calldata operationId) external view returns (address from, address to,
	                                                uint256 value, ClearableTransferStatusCode status);
	
	    function authorizeClearableTransferOperator(address operator) external returns (bool);
	    function revokeClearableTransferOperator(address operator) external returns (bool);
	    function isClearableTransferOperatorFor(address operator, address from) external view returns (bool);
	
	    event ClearableTransferOrdered(address indexed orderer, string operationId, address indexed from, address indexed to, uint256 value);
	    event ClearableTransferInProcess(address indexed orderer, string operationId);
	    event ClearableTransferExecuted(address indexed orderer, string operationId);
	    event ClearableTransferRejected(address indexed orderer, string operationId, string reason);
	    event ClearableTransferCancelled(address indexed orderer, string operationId);
	    event AuthorizedClearableTransferOperator(address indexed operator, address indexed account);
	    event RevokedClearableTransferOperator(address indexed operator, address indexed account);
	}
snippet erc2019i-draft Draft: EIP-2019: Fundable Token. An extension to the ERC-20 standard token that allows Token wallet owners to request a wallet to be funded, by calling the smart contract and attaching a fund instruction string.
	// https://eips.ethereum.org/EIPS/eip-2019
	// https://github.com/IoBuilders/fundable-token (example)
	// SPDX-License-Identifier: MIT
	/*
	An extension to the ERC-20 standard token that allows Token wallet owners to request a wallet to be funded, by calling the smart contract and attaching a fund instruction string.
	
	Token wallet owners (or approved addresses) can order tokenization requests through blockchain.
	This is done by calling the orderFund or orderFundFrom methods,
	which initiate the workflow for the token contract operator to either honor or reject the fund request.
	In this case, fund instructions are provided when submitting the request,
	which are used by the operator to determine the source of the funds to be debited in order to do fund the token wallet (through minting).
	*/
	pragma solidity >=0.5.0 <0.8.0;
	
	interface IFundable /* is ERC-20 */ {
	    enum FundStatusCode {
	        Nonexistent,
	        Ordered,
	        InProcess,
	        Executed,
	        Rejected,
	        Cancelled
	    }
	    function authorizeFundOperator(address orderer) external returns (bool);
	    function revokeFundOperator(address orderer) external returns (bool) ;
	    function orderFund(string calldata operationId, uint256 value, string calldata instructions) external returns (bool);
	    function orderFundFrom(string calldata operationId, address walletToFund, uint256 value,
	                                        string calldata instructions) external returns (bool);
	    function cancelFund(string calldata operationId) external returns (bool);
	    function processFund(string calldata operationId) external returns (bool);
	    function executeFund(string calldata operationId) external returns (bool);
	    function rejectFund(string calldata operationId, string calldata reason) external returns (bool);
	
	    function isFundOperatorFor(address walletToFund, address orderer) external view returns (bool);
	    function retrieveFundData(address orderer, string calldata operationId) external view returns (address walletToFund,
	    uint256 value, string memory instructions, FundStatusCode status);
	
	    event FundOrdered(address indexed orderer, string indexed operationId, address indexed , uint256 value, string instructions);
	    event FundInProcess(address indexed orderer, string indexed operationId);
	    event FundExecuted(address indexed orderer, string indexed operationId);
	    event FundRejected(address indexed orderer, string indexed operationId, string reason);
	    event FundCancelled(address indexed orderer, string indexed operationId);
	    event FundOperatorAuthorized(address indexed walletToFund, address indexed orderer);
	    event FundOperatorRevoked(address indexed walletToFund, address indexed orderer);
	}
snippet erc2020i-draft Draft: EIP-2020: E-Money Standard Token. The E-Money Standard Token aims to enable the issuance of regulated electronic money on blockchain networks, and its practical usage in real financial applications.
	// https://eips.ethereum.org/EIPS/eip-2020
	// https://github.com/IoBuilders/em-token (example)
	// SPDX-License-Identifier: MIT
	/*
	The E-Money Standard Token aims to enable the issuance of regulated electronic money on blockchain networks, and its practical usage in real financial applications.
	
	Financial institutions work today with electronic systems,
	which hold account balances in databases on core banking systems.
	In order for an institution to be allowed to maintain records of client balances segregated and available for clients,
	such institution must be regulated under a known legal framework and must possess a license to do so.
	Maintaining a license under regulatory supervision entails ensuring compliance (i.e. performing KYC on all clients and ensuring good AML practices before allowing transactions)
	and demonstrating technical and operational solvency through periodic audits,
	so clients depositing funds with the institution can rest assured that their money is safe.
	*/
	pragma solidity >=0.5.0 <0.8.0;
	
	interface EMoneyToken /* is ERC-1996, ERC-2018, ERC-2019, ERC-2021 */ {
	    function currency() external view returns (string memory);
	    function version() external pure returns (string memory);
	    function availableFunds(address account) external view returns (uint256);
	    function checkTransferAllowed(address from, address to, uint256 value) external view returns (byte status);
	    function checkApproveAllowed(address from, address spender, uint256 value) external view returns (byte status);
	    function checkHoldAllowed(address from, address to, address notary, uint256 value) external view returns (byte status);
	    function checkAuthorizeHoldOperatorAllowed(address operator, address from) external view returns (byte status);
	    function checkOrderTransferAllowed(address from, address to, uint256 value) external view returns (byte status);
	    function checkAuthorizeClearableTransferOperatorAllowed(address operator, address from) external view returns (byte status);
	    function checkOrderFundAllowed(address to, address operator, uint256 value) external view returns (byte status);
	    function checkAuthorizeFundOperatorAllowed(address operator, address to) external view returns (byte status);
	    function checkOrderPayoutAllowed(address from, address operator, uint256 value) external view returns (byte status);
	    function checkAuthorizePayoutOperatorAllowed(address operator, address from) external view returns (byte status);
	}
snippet erc2021i-draft Draft: EIP-2021: Payoutable Token: An extension to the ERC-20 standard token that allows Token wallet owners to request payout from their wallet, by calling the smart contract and attaching a payout instruction string.
	// https://eips.ethereum.org/EIPS/eip-2021
	// https://github.com/IoBuilders/payoutable-token (example)
	// SPDX-License-Identifier: MIT
	/*
	An extension to the ERC-20 standard token that allows Token wallet owners to request payout from their wallet,
	by calling the smart contract and attaching a payout instruction string.
	
	Token wallet owners (or approved addresses) can order payout requests through blockchain.
	This is done by calling the orderPayoutFrom or orderPayoutFrom methods,
	which initiate the workflow for the token contract operator to either honor or reject the payout request.
	In this case, payout instructions are provided when submitting the request, which are used by the operator to determine the destination of the funds.
	
	In general, it is not advisable to place explicit routing instructions for the payouts on a verbatim basis on the blockchain,
	and it is advised to use a private communication alternatives, such as private channels, encrypted storage or similar,
	to do so (external to the blockchain ledger). Another (less desirable) possibility is to place these instructions on the instructions field in encrypted form.
	*/
	
	pragma solidity >=0.5.0 <0.8.0;
	
	interface IPayoutable /* is ERC-20 */ {
	    enum PayoutStatusCode {
	        Nonexistent,
	        Ordered,
	        InProcess,
	        FundsInSuspense,
	        Executed,
	        Rejected,
	        Cancelled
	    }
	    function authorizePayoutOperator(address orderer) external returns (bool);
	    function revokePayoutOperator(address orderer) external returns (bool);
	    function orderPayout(string calldata operationId, uint256 value, string calldata instructions) external returns (bool);
	    function orderPayoutFrom(string calldata operationId, address walletToBePaidOut, uint256 value, string calldata instructions)
	                                                                                                                external returns (bool);
	    function cancelPayout(string calldata operationId) external returns (bool);
	    function processPayout(string calldata operationId) external returns (bool);
	    function putFundsInSuspenseInPayout(string calldata operationId) external returns (bool);
	    function executePayout(string calldata operationId) external returns (bool);
	    function rejectPayout(string calldata operationId, string calldata reason) external returns (bool);
	
	    function isPayoutOperatorFor(address walletToDebit, address orderer) external view returns (bool);
	    function retrievePayoutData(string calldata operationId) external view
	                    returns (address walletToDebit, uint256 value, string memory instructions, PayoutStatusCode status);
	
	    event PayoutOrdered(address indexed orderer, string indexed operationId, address indexed walletToDebit, uint256 value, string instructions);
	    event PayoutInProcess(address indexed orderer, string indexed operationId);
	    event PayoutFundsInSuspense(address indexed orderer, string indexed operationId);
	    event PayoutExecuted(address indexed orderer, string indexed operationId);
	    event PayoutRejected(address indexed orderer, string indexed operationId, string reason);
	    event PayoutCancelled(address indexed orderer, string indexed operationId);
	    event PayoutOperatorAuthorized(address indexed walletToBePaidOut, address indexed orderer);
	    event PayoutOperatorRevoked(address indexed walletToBePaidOut, address indexed orderer);
	}
snippet erc721i ERC-721 Non-Fungible Token Standard, A standard interface for non-fungible tokens, also known as deeds.
	// https://eips.ethereum.org/EIPS/eip-721, http://erc721.org/ 
	// SPDX-License-Identifier: MIT
	pragma solidity >=0.5.0 <0.8.0;
	
	/// @title ERC-721 Non-Fungible Token Standard
	/// @dev See https://eips.ethereum.org/EIPS/eip-721
	///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.
	interface ERC721 /* is ERC165 */ {
	    /// @dev This emits when ownership of any NFT changes by any mechanism.
	    ///  This event emits when NFTs are created (\`from\` == 0) and destroyed
	    ///  (\`to\` == 0). Exception: during contract creation, any number of NFTs
	    ///  may be created and assigned without emitting Transfer. At the time of
	    ///  any transfer, the approved address for that NFT (if any) is reset to none.
	    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);
	
	    /// @dev This emits when the approved address for an NFT is changed or
	    ///  reaffirmed. The zero address indicates there is no approved address.
	    ///  When a Transfer event emits, this also indicates that the approved
	    ///  address for that NFT (if any) is reset to none.
	    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);
	
	    /// @dev This emits when an operator is enabled or disabled for an owner.
	    ///  The operator can manage all NFTs of the owner.
	    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);
	
	    /// @notice Count all NFTs assigned to an owner
	    /// @dev NFTs assigned to the zero address are considered invalid, and this
	    ///  function throws for queries about the zero address.
	    /// @param _owner An address for whom to query the balance
	    /// @return The number of NFTs owned by \`_owner\`, possibly zero
	    function balanceOf(address _owner) external view returns (uint256);
	
	    /// @notice Find the owner of an NFT
	    /// @dev NFTs assigned to zero address are considered invalid, and queries
	    ///  about them do throw.
	    /// @param _tokenId The identifier for an NFT
	    /// @return The address of the owner of the NFT
	    function ownerOf(uint256 _tokenId) external view returns (address);
	
	    /// @notice Transfers the ownership of an NFT from one address to another address
	    /// @dev Throws unless \`msg.sender\` is the current owner, an authorized
	    ///  operator, or the approved address for this NFT. Throws if \`_from\` is
	    ///  not the current owner. Throws if \`_to\` is the zero address. Throws if
	    ///  \`_tokenId\` is not a valid NFT. When transfer is complete, this function
	    ///  checks if \`_to\` is a smart contract (code size > 0). If so, it calls
	    ///  \`onERC721Received\` on \`_to\` and throws if the return value is not
	    ///  \`bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))\`.
	    /// @param _from The current owner of the NFT
	    /// @param _to The new owner
	    /// @param _tokenId The NFT to transfer
	    /// @param data Additional data with no specified format, sent in call to \`_to\`
	    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) external payable;
	
	    /// @notice Transfers the ownership of an NFT from one address to another address
	    /// @dev This works identically to the other function with an extra data parameter,
	    ///  except this function just sets data to "".
	    /// @param _from The current owner of the NFT
	    /// @param _to The new owner
	    /// @param _tokenId The NFT to transfer
	    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;
	
	    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE
	    ///  TO CONFIRM THAT \`_to\` IS CAPABLE OF RECEIVING NFTS OR ELSE
	    ///  THEY MAY BE PERMANENTLY LOST
	    /// @dev Throws unless \`msg.sender\` is the current owner, an authorized
	    ///  operator, or the approved address for this NFT. Throws if \`_from\` is
	    ///  not the current owner. Throws if \`_to\` is the zero address. Throws if
	    ///  \`_tokenId\` is not a valid NFT.
	    /// @param _from The current owner of the NFT
	    /// @param _to The new owner
	    /// @param _tokenId The NFT to transfer
	    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;
	
	    /// @notice Change or reaffirm the approved address for an NFT
	    /// @dev The zero address indicates there is no approved address.
	    ///  Throws unless \`msg.sender\` is the current NFT owner, or an authorized
	    ///  operator of the current owner.
	    /// @param _approved The new approved NFT controller
	    /// @param _tokenId The NFT to approve
	    function approve(address _approved, uint256 _tokenId) external payable;
	
	    /// @notice Enable or disable approval for a third party ("operator") to manage
	    ///  all of \`msg.sender\`'s assets
	    /// @dev Emits the ApprovalForAll event. The contract MUST allow
	    ///  multiple operators per owner.
	    /// @param _operator Address to add to the set of authorized operators
	    /// @param _approved True if the operator is approved, false to revoke approval
	    function setApprovalForAll(address _operator, bool _approved) external;
	
	    /// @notice Get the approved address for a single NFT
	    /// @dev Throws if \`_tokenId\` is not a valid NFT.
	    /// @param _tokenId The NFT to find the approved address for
	    /// @return The approved address for this NFT, or the zero address if there is none
	    function getApproved(uint256 _tokenId) external view returns (address);
	
	    /// @notice Query if an address is an authorized operator for another address
	    /// @param _owner The address that owns the NFTs
	    /// @param _operator The address that acts on behalf of the owner
	    /// @return True if \`_operator\` is an approved operator for \`_owner\`, false otherwise
	    function isApprovedForAll(address _owner, address _operator) external view returns (bool);
	}
	
	interface ERC165 {
	    /// @notice Query if a contract implements an interface
	    /// @param interfaceID The interface identifier, as specified in ERC-165
	    /// @dev Interface identification is specified in ERC-165. This function
	    ///  uses less than 30,000 gas.
	    /// @return \`true\` if the contract implements \`interfaceID\` and
	    ///  \`interfaceID\` is not 0xffffffff, \`false\` otherwise
	    function supportsInterface(bytes4 interfaceID) external view returns (bool);
	}
snippet erc725i-draft Draft: EIP-725: Proxy Account. Standard functions for a unique identifiable proxy account to be used by humans, groups, organisations, objects and machines
	// https://eips.ethereum.org/EIPS/eip-725
	// https://github.com/ERC725Alliance/ERC725 (example)
	// SPDX-License-Identifier: MIT
	pragma solidity >=0.5.0 <0.8.0;
	
	/*
	The following describes standard functions for a unique identifiable proxy account to be used by humans, groups, organisations, objects and machines.
	The proxy has 2 abilities: (1) it can execute arbitrary contract calls, and (2) it can hold arbitrary data through a generic key/value store.
	One of these keys should hold the owner of the contract. The owner may be an address or a key manager contract for more complex management logic.
	Most importantly, this contract should be the reference point for a long-lasting identifiable profiles.
	*/
	interface ERC725 {
	    event DataChanged(bytes32 indexed key, bytes32 indexed value);
	    event OwnerChanged(address indexed ownerAddress);
	    event ContractCreated(address indexed contractAddress);
	
	    // address public owner;
	
	    function changeOwner(address _owner) external;
	    function getData(bytes32 _key) external view returns (bytes32 _value);
	    function setData(bytes32 _key, bytes32 _value) external;
	    function execute(uint256 _operationType, address _to, uint256 _value, bytes calldata _data) external;
	}
snippet erc777i ERC777 token standard, extending ERC20
	// https://eips.ethereum.org/EIPS/eip-777
	// Example implementation https://github.com/0xjac/ERC777/blob/master/contracts/examples/ReferenceToken.sol
	// SPDX-License-Identifier: MIT
	pragma solidity >=0.5.0 <0.8.0;
	
	interface ERC777Token {
	    function name() external view returns (string memory);
	    function symbol() external view returns (string memory);
	    function totalSupply() external view returns (uint256);
	    function balanceOf(address holder) external view returns (uint256);
	    function granularity() external view returns (uint256);
	
	    function defaultOperators() external view returns (address[] memory);
	    function isOperatorFor(
	        address operator,
	        address holder
	    ) external view returns (bool);
	    function authorizeOperator(address operator) external;
	    function revokeOperator(address operator) external;
	
	    function send(address to, uint256 amount, bytes calldata data) external;
	    function operatorSend(
	        address from,
	        address to,
	        uint256 amount,
	        bytes calldata data,
	        bytes calldata operatorData
	    ) external;
	
	    function burn(uint256 amount, bytes calldata data) external;
	    function operatorBurn(
	        address from,
	        uint256 amount,
	        bytes calldata data,
	        bytes calldata operatorData
	    ) external;
	
	    event Sent(
	        address indexed operator,
	        address indexed from,
	        address indexed to,
	        uint256 amount,
	        bytes data,
	        bytes operatorData
	    );
	    event Minted(
	        address indexed operator,
	        address indexed to,
	        uint256 amount,
	        bytes data,
	        bytes operatorData
	    );
	    event Burned(
	        address indexed operator,
	        address indexed from,
	        uint256 amount,
	        bytes data,
	        bytes operatorData
	    );
	    event AuthorizedOperator(
	        address indexed operator,
	        address indexed holder
	    );
	    event RevokedOperator(address indexed operator, address indexed holder);
	}
snippet error
	error ${1:name}(${2:type} ${3:name} $0);
snippet ev
	event ${1:name}(${2:type} ${3:name} $0);
snippet for
	for (uint256 ${1:index} = 0; $1 < ${2:array}.length; $1${3:++}) {
		$0
	}
snippet func
	function ${1:name}(${2:type} ${3:name}) {
		$0
	}
snippet funcr
	function ${1:name}(${2:type} ${3:name}) returns (${4:type} ${5:name}) {
		$0
	}
snippet funcrview
	function ${1:name}(${2:type} ${3:name}) view public returns (${4:type} ${5:name}) {
		$0
	}
snippet ife
	if (${1:condition}) {
		$2
	} else {
		$0
	}
snippet im
	import '${1:contract}';
snippet interf
	interface ${1:Name} {
		$0
	}
snippet lib
	library ${1:Name} {
		$0
	}
snippet map
	mapping (${1:type1}=>${2:type2}) ${3:name};
snippet mod
	modifier ${1:name}($2) {
		$0_
	}
snippet ///nat_contract natspec for contract
	/// @title A title that should describe the contract/interface
	/// @author The name of the author
	/// @notice Explain to an end user what this does
	/// @dev Explain to a developer any extra details
snippet ///nat_event natspec for event
	/// @notice Explain to an end user what this does
	/// @dev Explain to a developer any extra details
	/// @param Documents a parameter just like in doxygen (must be followed by parameter name)
snippet ///nat_function natspec for function
	/// @notice Explain to an end user what this does
	/// @dev Explain to a developer any extra details
	/// @param Documents a parameter just like in doxygen (must be followed by parameter name)
	/// @return Documents the return variables of a contract’s function state variable
	/// @inheritdoc	Copies all missing tags from the base function (must be followed by the contract name)
snippet ///nat_statevariable natspec for state variable
	/// @notice Explain to an end user what this does
	/// @dev Explain to a developer any extra details
	/// @return Documents the return variables of a contract’s function state variable
	/// @inheritdoc	Copies all missing tags from the base function (must be followed by the contract name)
snippet pragm-abicoder
	pragma abicoder v2;
snippet pra
	pragma solidity ${1:version};
snippet pragm-ex
	pragma solidity >=0.5.0 <0.8.0;
snippet solidityTips solidity tips
	//Paul Razvan Berg tips (@PaulRBerg)
	1️⃣ Use "type(uint256).max" instead of "uint256(-1)"
	2️⃣ Surround code with {} to avoid "stack too deep"
	3️⃣ Skip tuple vars with commas: "uint a, , ,"
	4️⃣ Swap vars in one line: "(a,b)=(b,a)"
	5️⃣ Use "assert" and get built-in formal verification with SMTChecker
	
	-----------------------------------------------
	
	// Daniel Luca tips (CleanUnicorn.eth)
	1️⃣  You can format numbers in Solidity using underscores.
	i.e.,
	1_000 is a thousand
	1_0_0_0 is a thousand
	1_000e0_3 is a million
	
	Python spec https://www.python.org/dev/peps/pep-0515/
	
	------------------------------
	Contribute tips here: https://github.com/juanfranblanco/vscode-solidity/blob/master/snippets/solidity.json#L197-L201 
	Escape the text using: https://www.freeformatter.com/json-escape.html
	------------------------------
	
snippet spdx SPDX License
	// SPDX-License-Identifier: MIT
snippet unchecked
	unchecked {
		$0
	}
snippet uniV2Factory Uniswap Factory
	// https://uniswap.org/docs/v2/smart-contracts/factory/
	// https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2Factory.solimplementation
	// SPDX-License-Identifier: MIT
	// UniswapV2Factory is deployed at 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f on the Ethereum mainnet, and the Ropsten, Rinkeby, Görli, and Kovan testnets
	pragma solidity >=0.5.0;
	
	interface IUniswapV2Factory {
	  event PairCreated(address indexed token0, address indexed token1, address pair, uint);
	
	  function getPair(address tokenA, address tokenB) external view returns (address pair);
	  function allPairs(uint) external view returns (address pair);
	  function allPairsLength() external view returns (uint);
	
	  function feeTo() external view returns (address);
	  function feeToSetter() external view returns (address);
	
	  function createPair(address tokenA, address tokenB) external returns (address pair);
	}
snippet uniV2Pair Uniswap Pair Interface
	// https://uniswap.org/docs/v2/smart-contracts/pair/
	// https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2Pair.sol implementation
	// SPDX-License-Identifier: MIT
	
	pragma solidity >=0.5.0;
	
	interface IUniswapV2Pair {
	  event Approval(address indexed owner, address indexed spender, uint value);
	  event Transfer(address indexed from, address indexed to, uint value);
	
	  function name() external pure returns (string memory);
	  function symbol() external pure returns (string memory);
	  function decimals() external pure returns (uint8);
	  function totalSupply() external view returns (uint);
	  function balanceOf(address owner) external view returns (uint);
	  function allowance(address owner, address spender) external view returns (uint);
	
	  function approve(address spender, uint value) external returns (bool);
	  function transfer(address to, uint value) external returns (bool);
	  function transferFrom(address from, address to, uint value) external returns (bool);
	
	  function DOMAIN_SEPARATOR() external view returns (bytes32);
	  function PERMIT_TYPEHASH() external pure returns (bytes32);
	  function nonces(address owner) external view returns (uint);
	
	  function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
	
	  event Mint(address indexed sender, uint amount0, uint amount1);
	  event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
	  event Swap(
	      address indexed sender,
	      uint amount0In,
	      uint amount1In,
	      uint amount0Out,
	      uint amount1Out,
	      address indexed to
	  );
	  event Sync(uint112 reserve0, uint112 reserve1);
	
	  function MINIMUM_LIQUIDITY() external pure returns (uint);
	  function factory() external view returns (address);
	  function token0() external view returns (address);
	  function token1() external view returns (address);
	  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
	  function price0CumulativeLast() external view returns (uint);
	  function price1CumulativeLast() external view returns (uint);
	  function kLast() external view returns (uint);
	
	  function mint(address to) external returns (uint liquidity);
	  function burn(address to) external returns (uint amount0, uint amount1);
	  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
	  function skim(address to) external;
	  function sync() external;
	}
snippet uniV2PairERC20 Uniswap Pair ERC20 Interface
	// https://uniswap.org/docs/v2/smart-contracts/pair-erc-20/
	// https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2Pair.sol implementation
	// SPDX-License-Identifier: MIT
	
	pragma solidity >=0.5.0;
	
	interface IUniswapV2ERC20 {
	  event Approval(address indexed owner, address indexed spender, uint value);
	  event Transfer(address indexed from, address indexed to, uint value);
	
	  function name() external pure returns (string memory);
	  function symbol() external pure returns (string memory);
	  function decimals() external pure returns (uint8);
	  function totalSupply() external view returns (uint);
	  function balanceOf(address owner) external view returns (uint);
	  function allowance(address owner, address spender) external view returns (uint);
	
	  function approve(address spender, uint value) external returns (bool);
	  function transfer(address to, uint value) external returns (bool);
	  function transferFrom(address from, address to, uint value) external returns (bool);
	
	  function DOMAIN_SEPARATOR() external view returns (bytes32);
	  function PERMIT_TYPEHASH() external pure returns (bytes32);
	  function nonces(address owner) external view returns (uint);
	
	  function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
	}
snippet uniV2Router01 Uniswap Router01
	// https://uniswap.org/docs/v2/smart-contracts/router01/
	// https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/UniswapV2Router01.sol implementation
	// UniswapV2Router01 is deployed at 0xf164fC0Ec4E93095b804a4795bBe1e041497b92a on the Ethereum mainnet, and the Ropsten, Rinkeby, Görli, and Kovan testnets
	
	// SPDX-License-Identifier: MIT
	pragma solidity >=0.6.2;
	
	interface IUniswapV2Router01 {
	  function factory() external pure returns (address);
	  function WETH() external pure returns (address);
	
	  function addLiquidity(
	      address tokenA,
	      address tokenB,
	      uint amountADesired,
	      uint amountBDesired,
	      uint amountAMin,
	      uint amountBMin,
	      address to,
	      uint deadline
	  ) external returns (uint amountA, uint amountB, uint liquidity);
	  function addLiquidityETH(
	      address token,
	      uint amountTokenDesired,
	      uint amountTokenMin,
	      uint amountETHMin,
	      address to,
	      uint deadline
	  ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
	  function removeLiquidity(
	      address tokenA,
	      address tokenB,
	      uint liquidity,
	      uint amountAMin,
	      uint amountBMin,
	      address to,
	      uint deadline
	  ) external returns (uint amountA, uint amountB);
	  function removeLiquidityETH(
	      address token,
	      uint liquidity,
	      uint amountTokenMin,
	      uint amountETHMin,
	      address to,
	      uint deadline
	  ) external returns (uint amountToken, uint amountETH);
	  function removeLiquidityWithPermit(
	      address tokenA,
	      address tokenB,
	      uint liquidity,
	      uint amountAMin,
	      uint amountBMin,
	      address to,
	      uint deadline,
	      bool approveMax, uint8 v, bytes32 r, bytes32 s
	  ) external returns (uint amountA, uint amountB);
	  function removeLiquidityETHWithPermit(
	      address token,
	      uint liquidity,
	      uint amountTokenMin,
	      uint amountETHMin,
	      address to,
	      uint deadline,
	      bool approveMax, uint8 v, bytes32 r, bytes32 s
	  ) external returns (uint amountToken, uint amountETH);
	  function swapExactTokensForTokens(
	      uint amountIn,
	      uint amountOutMin,
	      address[] calldata path,
	      address to,
	      uint deadline
	  ) external returns (uint[] memory amounts);
	  function swapTokensForExactTokens(
	      uint amountOut,
	      uint amountInMax,
	      address[] calldata path,
	      address to,
	      uint deadline
	  ) external returns (uint[] memory amounts);
	  function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
	      external
	      payable
	      returns (uint[] memory amounts);
	  function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
	      external
	      returns (uint[] memory amounts);
	  function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
	      external
	      returns (uint[] memory amounts);
	  function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
	      external
	      payable
	      returns (uint[] memory amounts);
	
	  function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
	  function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
	  function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
	  function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
	  function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
	}
snippet uniV2Router02 Uniswap Router02
	// https://uniswap.org/docs/v2/smart-contracts/router02/
	// https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/UniswapV2Router02.sol implementation
	// UniswapV2Router02 is deployed at 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D on the Ethereum mainnet, and the Ropsten, Rinkeby, Görli, and Kovan testnets.
	
	// SPDX-License-Identifier: MIT
	pragma solidity >=0.6.2;
	
	// You can add this typing "uniV2Router01" 
	import './IUniswapV2Router01.sol';
	
	interface IUniswapV2Router02 is IUniswapV2Router01 {
	    function removeLiquidityETHSupportingFeeOnTransferTokens(
	        address token,
	        uint liquidity,
	        uint amountTokenMin,
	        uint amountETHMin,
	        address to,
	        uint deadline
	    ) external returns (uint amountETH);
	    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
	        address token,
	        uint liquidity,
	        uint amountTokenMin,
	        uint amountETHMin,
	        address to,
	        uint deadline,
	        bool approveMax, uint8 v, bytes32 r, bytes32 s
	    ) external returns (uint amountETH);
	
	    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
	        uint amountIn,
	        uint amountOutMin,
	        address[] calldata path,
	        address to,
	        uint deadline
	    ) external;
	    function swapExactETHForTokensSupportingFeeOnTransferTokens(
	        uint amountOutMin,
	        address[] calldata path,
	        address to,
	        uint deadline
	    ) external payable;
	    function swapExactTokensForETHSupportingFeeOnTransferTokens(
	        uint amountIn,
	        uint amountOutMin,
	        address[] calldata path,
	        address to,
	        uint deadline
	    ) external;
	}
