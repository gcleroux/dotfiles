# Generated by snippet-converter.nvim (https://github.com/smjonas/snippet-converter.nvim)

snippet al Allocate Array
	allocate(${1:array}, stat=${2:err})
	if ($2 /= 0) print *, "$1: Allocation request denied"
snippet all all
	all(${1:mask}${2:, dim=${3:1}})
snippet alloc Allocate and Deallocate array
	allocate(${1:array}, stat=${2:err})
	if ($2 /= 0) print *, "$1: Allocation request denied"
	
	if (allocated($1)) deallocate($1, stat=$2)
	if ($2 /= 0) print *, "$1: Deallocation request denied"
snippet and And
	.and.
snippet any any
	any(${1:mask}${2:, dim=${3:1}})
snippet c Quick Character
	character(len=*) :: 
snippet case case
	case ${1:default}
		$0
snippet char Character
	character(len=$1${2:, kind=$3})${4:, ${5:attributes}} :: ${6:name}
snippet close Close File
	close(unit=${1:iounit}, iostat=${2:ios}${3:, status="delete"})
	if ($2 /= 0) stop "Error closing file unit $1"
	
snippet count count
	count(${1:mask}${2:, dim=${3:1}})
snippet cy cycle
	cycle
snippet data data
	data ${1:variable} / ${2:data} /
snippet deal Deallocate Array
	if (allocated($1)) deallocate(${1:array}, stat=${2:err})
	if ($2 /= 0) print *, "$1: Deallocation request denied$0"
snippet do do
	do${1: ${2:i} = ${3:1}, ${4:100}, ${5:1}}
		$0
	end do
snippet dot Dot Product of Vectors
	dot_product($1,$2)
snippet dow do while
	do while (${1:condition})
		$0
	end do
snippet elif else if
	else if (${1:condition}) then
		
snippet eq Equal
	.eq.
snippet eqv Equality
	.eqv.
snippet fa .false.
	.false.
snippet for forall
	forall (${1:i=1:100}${2:, mask})
		$0
	end forall
snippet fun function
	function ${1:name}(${2:input}) result(${3:output})
		${4:argument type}, intent(${5:inout}) :: $2
		${6:function type} :: $3
		$0
	end function $1
snippet ge Greater or Equal
	.ge.
snippet gt Greater Than
	.gt.
snippet i Quick Integer
	integer :: 
snippet ido Implied do
	(${1:i}, $1 = ${2:1}, ${3:100}, ${4:1})$0
snippet if if (single line)
	if (${1:condition}) 
snippet if if
	if (${1:condition}) then
		$0
	end if
snippet imp implicit none
	implicit none
	
snippet inq Inquire (by Filename)
	inquire(file=${1:filename}, opened=${2:ioopen}, exists=${3:ioexist}, number=${4:iounit})
snippet inq Inquire (by Unit)
	inquire(unit=${1:iounit}, opened=${2:ioopen}, name=${3:filename}, action=${4:ioaction})
snippet int Integer
	integer${1:(${2:kind})}${3:, ${4:attributes}} :: ${5:name}
snippet interf interface
	interface ${1:name}
		$0
	end interface $1
snippet l Quick Logical
	logical :: 
snippet lbound Lower Bound
	lbound(${1:source}${2:, dim=${3:1}})
snippet le Less or Equal
	.le.
snippet log Logical
	logical${1:(${2:kind})}${3:, ${4:attributes}} :: ${5:name}
snippet lt Less Than
	.lt.
snippet mat Matrix Multiplication
	matmul($1,$2)
snippet max max
	max($1, $2\${, $3:...})$0
snippet maxloc Index of Maximum
	maxloc(${1:source}${2:, mask=${3:($1>0)}})
snippet maxval Maximum Value
	maxval(${1:source}${2:, dim=${3:1}}${4:, mask=${5:($1>0)}})
snippet merge merge
	merge(${1:source}, ${2:alternative}, mask=(${2:$1>0}))
snippet min min
	min($1, $2\${, $3:...})$0
snippet minloc Index of Minimum
	minloc(${1:source}${2:, mask=${3:$1>0}})
snippet minval Minimum Value
	minval(${1:source}${2:, dim=${3:1}}${4:, mask=${5:($1>0)}})
snippet mod module
	module ${1:name}
	
		implicit none
		$0
	
	end module $1
	
snippet mp module procedure
	module procedure ${0:name}
snippet neqv Non-Equality
	.neqv.
snippet not Not
	.not.
snippet op Quick Open
	open(unit=${1:iounit}, file=${2:name}, iostat=${3:ios})
	if ($3 /= 0) stop "Error opening file ${2/[\"\'](.*)[\"\']/table: 0x7f41780d8948/}"
snippet open Input File
	open(unit=${1:iounit}, file=${2:name}, iostat=${3:ios}, status="${4:old}", action="${5:read}")
	if ($3 /= 0) stop "Error opening file ${2/[\"\'](.*)[\"\']/table: 0x7f4173e022c0/}"
	
snippet open Open File
	open(unit=${1:iounit}, file=${2:name}, iostat=${3:ios}, &
	     status="${4:old/new/replace/scratch/unknown}", action="${5:read/write/readwrite}", access="${7:sequential/direct}"${7/(direct)$|.*/table: 0x7f4173b0a0c0/}$0)
	if ($3 /= 0) stop "Error opening file ${2/[\"\'](.*)[\"\']/table: 0x7f4173a1b870/}"
snippet open Output File
	open(unit=${1:iounit}, file=${2:name}, iostat=${3:ios}, status="${4:new}", action="${5:write}")
	if ($3 /= 0) stop "Error opening file ${2/[\"\'](.*)[\"\']/table: 0x7f4173aba330/}"
	
snippet open Scratch File
	open(unit=${1:iounit}, iostat=${3:ios}, status="${4:scratch}", action="${5:readwrite}")
	if ($3 /= 0) stop "Error opening scratch file on unit $1"
	
snippet or Or
	.or.
snippet pack pack
	pack(${1:array}, mask=(${2:$1>0})${3:, vector=${4:destination vector}})
snippet pr Quick Print
	print*, 
snippet prod Product of Elements
	product(${1:source}${2:, dim=${3:1}}${4:, mask=${5:($1>0)}})
snippet prog program
	program ${1:name}
	
		implicit none
		$0
	
	end program $1
	
snippet r Quick Real
	real :: 
snippet re Quick Read
	read*, 
snippet rea Real
	real${1:(${2:kind})}${3:, ${4:attributes}} :: ${5:name}
snippet read Read (Non Advancing Mode)
	read(unit=${1:iounit}, fmt="(${2:format string})", iostat=${3:istat}, advance='NO', size=${4:number of characters}) ${5:variables}
	if ($3 /= 0) stop "Read error in file unit $1"
	
snippet read Read
	read(unit=${1:iounit}, fmt="(${2:format string})", iostat=${3:istat}) ${4:variables}
	if ($3 /= 0) stop "Read error in file unit $1"
	
snippet resh reshape
	reshape(${1:source}${2:, shape=(/$3/)}${4:, pad=(/$5/)}${6:, order=(/${7:2,1}/)})
snippet rn Random Number
	call random_number($0)
snippet rs Random Seed
	call random_seed(${1:size=${2:<int>}}${3:put=(/$4/)})
snippet sel select case
	select case ($1:variable)
		case ($2:values)
			$0
	end select
snippet size Size
	size(${1:source}${2:, dim=${3:1}})
snippet spread spread
	spread(${1:source}, dim=${2:1}, ncopies=$3)
snippet stop stop
	stop "${1:message}"
snippet sub subroutine
	subroutine ${1:name}(${2:input})
		${3:argument type}, intent(${4:inout}) :: ${2/\w+\((.*)\)|.*/table: 0x7f4173688558/}
		$0
	end subroutine ${1/(\w+).*/table: 0x7f417368fec8/}
snippet sum Sum of Elements
	sum(${1:source}${2:, dim=${3:1}}${4:, mask=${5:($1>0)}})
snippet t Quick Custom Type
	type(${1:type name}) :: 
snippet tr .true.
	.true.
snippet typ Custom Type
	type(${1:type name})${2:, ${3:attributes}} :: ${4:name}
snippet type Type Definition
	type ${1:type name}
		$0
	end type $1
snippet ubound Upper Bound
	ubound(${1:source}${2:, dim=${3:1}})
snippet unpack unpack
	unpack(${1:vector}, mask=(${2:$1>0}), field=${3:destination array})
snippet wh where (single line)
	where ($1 ${2:==} $3) 
snippet whe where
	where ($1 ${2:==} $3)
		$0
	end where
snippet wr Quick Write
	write(unit=${1:iounit}, fmt=*) ${0:variables}
	
snippet write Write
	write(unit=${1:iounit}, fmt="(${2:format string})", iostat=${3:ios}${4:, advance='NO'}) ${5:variables}
	if ($3 /= 0) stop "Write error in file unit $1"
	
