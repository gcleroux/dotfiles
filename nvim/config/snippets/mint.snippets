# Generated by snippet-converter.nvim (https://github.com/smjonas/snippet-converter.nvim)

snippet button HTML elements can be written as in standard HTML.
	<${1:button}::${2:stylename} ${3:disabled}={${4:disabled}}>
		<{ "${5:Text}" }>
	</${1:button}>
snippet case A case expression is useful for matching enums or exact values, while also supporting a default value.
	case (${1:condition}) {
		${2:match1} => ${3:value1}
		${4:match3} => ${5:value3}
		=> ${6:defaultValue}
	}
snippet com Components are reusable pieces of code that have specific behavior, styles and content.
	component ${1:ComponentName} {
		$0
	}
snippet tag Tags that have the name of a component will render that component at the point where the tag is defined.
	<${1:Component} ${2:attribute}={${3:value}}/>
snippet get Computed properties works like regular properties but instead of returning a constant value it can return different values base on the state and the properties.
	get ${1:computedProperty} : ${2:String} {
		$0
	}
snippet con The connect directive lets you connect a component to a store which allows you to call the stores functions and properties without using the stores name.
	connect ${1:StoreName}.Store exposing { $0 }
snippet do do expressions are for two things: handling asynchronous computations that might fail, for example when loading something with a request, or executing asynchronous expressions sequentially.
	do {
		$1
	} catch ${2:Http}.Error => error {
		$3
	}
snippet fun Functions can be defined on modules, components, stores and providers.
	fun ${1:name}(${2:object} : ${3:String}) : ${4:Void} {
		$0
	}
snippet div HTML elements can be written as in standard HTML.
	<${1:div}::${2:stylename}>
		$0
	</${1:div}>
snippet if The if...else conditional expression can return two different values based on a condition.
	if (${1:condition}) {
		${2:value}
	} else {
		${3:otherValue}
	}
snippet main The component named Main is the one that get's rendered on the screen.
	component Main {
		fun render : Html {
			<$0/>
		}
	}
snippet mod Modules are kind of containers for a set of relatable functions, usually used to gather functions that relate to a specific type.
	module ${1:ModuleName} {
		$0
	}
snippet next Functions can be defined on modules, components, stores and providers.
	next { state | ${1:name} = ${1:name} + 1 }
snippet p HTML elements can be written as in standard HTML.
	<${1:p}::${2:stylename}>
		$0
	</${1:p}>
snippet record Records are object like data structures, that have a fix set of keys and values.
	record ${1:User} {
		${2:name} : ${3:String},
		${4:email} : ${5:String}
	}
snippet render The render function renders the component into an HTML tree.
	fun render : Html {
		$0
	}
snippet routes In Mint routes of an application are defined at the top level with the routes block.
	routes {
		/ {
			${1:Application.setPage("index")}
		}
		/${2:user}/:${3:id} {
			 do {
				${4:Application.setPage("show")}
				${5:Application.loadUser(id)}
			}
		}
	}
snippet span HTML elements can be written as in standard HTML.
	<${1:span}::${2:stylename}>
		$0
	</${1:span}>
snippet store Stores are global containers of application specific data.
	store ${1:StoreName}.Store {
		$0
	}
snippet prop The property keyword when used in a store defines part of the data that the store contains.
	property ${1:name} : ${2:Number} = ${0:0}
snippet sty Styles define with CSS how an HTML element looks.
	style ${1:base} {
		${2:attribute}: ${3:value};
	}
snippet h HTML elements can be written as in standard HTML.
	<${1:h1}::${2:stylename}>
		$0
	</${1:h1}>
snippet try try is a control expression for handling synchronous computations that might fail, for example when you are trying to convert an untyped JavaScript object into a typed Record.
	try {
		$1
	} catch ${2:Json}.Error => error {
		$3
	}
