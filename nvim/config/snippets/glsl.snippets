# Generated by snippet-converter.nvim (https://github.com/smjonas/snippet-converter.nvim)

snippet PI PI setup
	const float PI = 3.14159265359;
snippet abs float abs(float x) vec2 abs(vec2 x) vec3 abs(vec3 x) vec4 abs(vec4 x)  The abs function returns the absolute value of x, i.e. x when x is positive or zero and -x for negative x. The input parameter can be a floating scalar or a float vector. In case of a float vector the operation is done component-wise.
	abs($2)
snippet acos float acos(float x) vec2 acos(vec2 x) vec3 acos(vec3 x) vec4 acos(vec4 x)  The acos function returns the arccosine of an angle in radians. It is the inverse function of cosine. The input parameter can be a floating scalar or a float vector. In case of a float vector the arccosine is calculated separately for every component.
	acos($2)
snippet acosh return the arc hyperbolic cosine of the parameter
	acosh($2)
snippet asin float asin(float x) vec2 asin(vec2 x) vec3 asin(vec3 x) vec4 asin(vec4 x)  The asin function returns the arcsine of an angle in radians. It is the inverse function of sine. The input parameter can be a floating scalar or a float vector. In case of a float vector the arcsine is calculated separately for every component.
	asin($2)
snippet asinh return the arc hyperbolic sine of the parameter - inverse of sinh
	asinh($2)
snippet atan float atan(float y_over_x) vec2 atan(vec2 y_over_x) vec3 atan(vec3 y_over_x) vec4 atan(vec4 y_over_x)  The atan function returns the arctangent of an angle in radians. It is the inverse function of tangent. The input parameter can be a floating scalar or a float vector. In case of a float vector the arctangent is calculated separately for every component.  float atan(float y, float x) vec2 atan(vec2 y, vec2 x) vec3 atan(vec3 y, vec3 x) vec4 atan(vec4 y, vec4 x)  There is also a two-argument variation of the atan function (in other programming languages often called atan2). For a point with Cartesian coordinates (x, y) the function returns the angle θ of the same point with polar coordinates (r, θ).
	atan($2, $3)
snippet attribute The qualifier attribute is used to declare variables that are shared between a vertex shader and the OpenGL ES environment. Since the vertex shader is executed one time for each vertex attributes are used to specify per vertex data. They typically provide data such as the object space position, the normal direction and the texture coordinates of a vertex. Attributes are read-only variables, i.e. their value can not be changed in the vertex shader. Side note: Since an attribute is never initialized in the shader it has to be loaded with data by the application executing the shader.
	attribute
snippet break The keyword break is used inside the body of a loop to abort the whole loop. All statements in the body after the break statement are ignored and the loop is exited without executing any further iteration.
	break;
snippet ceil float ceil(float x) vec2 ceil(vec2 x) vec3 ceil(vec3 x) vec4 ceil(vec4 x)  The ceiling function returns the smallest number that is larger or equal to x. The input parameter can be a floating scalar or a float vector. In case of a float vector the operation is done component-wise.  Side note: The return value is of type floating scalar or float vector although the result of the operation is an integer.
	ceil($2)
snippet clamp float clamp(float x, float minVal, float maxVal) vec2 clamp(vec2 x, vec2 minVal, vec2 maxVal) vec3 clamp(vec3 x, vec3 minVal, vec3 maxVal) vec4 clamp(vec4 x, vec4 minVal, vec4 maxVal)  The clamp function returns x if it is larger than minVal and smaller than maxVal. In case x is smaller than minVal, minVal is returned. If x is larger than maxVal, maxVal is returned. The input parameters can be floating scalars or float vectors. In case of float vectors the operation is done component-wise.  float clamp(float x, float minVal, float maxVal) vec2 clamp(vec2 x, float minVal, float maxVal) vec3 clamp(vec3 x, float minVal, float maxVal) vec4 clamp(vec4 x, flfloat minVal, float maxVal)  There is also a variation of the clamp function where the second and third parameters are always a floating scalars.
	clamp($2, $3, $4)
snippet const The qualifier const is used for variables that are compile-time constants or for function parameters that are read-only.
	const
snippet continue The keyword continue is used inside the body of a loop to abort a single pass of the loop. All statements in the body after the continue statement are ignored and the next iteration of the loop is executed immediately.
	continue;
snippet cos float cos(float angle) vec2 cos(vec2 angle) vec3 cos(vec3 angle) vec4 cos(vec4 angle)  The cos function returns the cosine of an angle in radians. The input parameter can be a floating scalar or a float vector. In case of a float vector the cosine is calculated separately for every component.
	cos($2)
snippet cosh return the hyperbolic cosine of the parameter
	cosh($2)
snippet cross vec3 cross(vec3 x, vec3 y)  The cross function returns the cross product of the two input parameters, i.e. a vector that is perpendicular to the plane containing x and y and has a magnitude that is equal to the area of the parallelogram that x and y span. The input parameters can only be 3-component floating vectors. The cross product is equivalent to the product of the length of the vectors times the sinus of the(smaller) angle between x and y.
	cross($2, $3, $4)
snippet degrees float degrees(float radians) vec2 degrees(vec2 radians) vec3 degrees(vec3 radians) vec4 degrees(vec4 radians)  The degrees function converts radians to degrees. The input parameter can be a floating scalar or a float vector. In case of a float vector every component is converted from radians to degrees separately.
	degrees($2)
snippet discard The keyword discard is used to define an exceptionally exit for a fragment shader. It is used exit the fragment shader immediately and to signal the OpenGL ES 2.0 pipeline that the respective fragment should not be drawn.
	discard;
snippet distance float distance(float p0, float p1) float distance(vec2 p0, vec2 p1) float distance(vec3 p0, vec3 p1) float distance(vec4 p0, vec4 p1)  The distance function returns the distance between two points. The distance of two points is the length of the vector d = p0 - p1, that starts at p1 and points to p0. The input parameters can be floating scalars or float vectors. In case of floating scalars the distance function is trivial and returns the absolute value of d.
	distance($2, $3)
snippet dot float dot(float x, float y) float dot(vec2 x, vec2 y) float dot(vec3 x, vec3 y) float dot(vec4 x, vec4 y)  The dot function returns the dot product of the two input parameters, i.e. the sum of the component-wise products. If x and y are the same the square root of the dot product is equivalent to the length of the vector. The input parameters can be floating scalars or float vectors. In case of floating scalars the dot function is trivial and returns the product of x and y.
	dot($2, $3)
snippet dowhile do { 	//code }while();  The keyword do is used in combination with while to describe a loop that is controlled by a condition. The body defined by curly braces encloses the statements that are executed at each pass of the loop. The parentheses enclose the expression that defines the condition.  do { 	aFunction(); } while(i <= 99);  The execution of a single pass or the whole loop can be aborted by using a continue or a break statement respectively.  In contrast to a simple while loop the body is always executed at least one time even if the expression evaluates to false from the beginning.
	do{
		
	} while($2){
		
	}
snippet equal perform a component-wise equal-to comparison of two vectors
	equal($2, $3)
snippet exp float exp(float x) vec2 exp(vec2 x) vec3 exp(vec3 x) vec4 exp(vec4 x)  The exp function returns the constant e raised to the power of x. The input parameter can be a floating scalar or a float vector. In case of a float vector the operation is done component-wise.
	exp($2);
snippet exp2 float exp2(float x) vec2 exp2(vec2 x) vec3 exp2(vec3 x) vec4 exp2(vec4 x)  The exp2 function returns 2 raised to the power of x. The input parameter can be a floating scalar or a float vector. In case of a float vector the operation is done component-wise.
	exp2($2)
snippet faceforward float faceforward(float N, float I, float Nref) vec2 faceforward(vec2 N, vec2 I, vec2 Nref) vec3 faceforward(vec3 N, vec3 I, vec3 Nref) vec4 faceforward(vec4 N, vec4 I, vec4 Nref)  The faceforward function returns a vector that points in the same direction as a reference vector. The function has three input parameters of the type floating scalar or float vector: N, the vector to orient, I, the incident vector, and Nref, the reference vector. If the dot product of I and Nref is smaller than zero the return value is N. Otherwise -N is returned.
	faceforward($2, $3, $4)
snippet floor float floor(float x) vec2 floor(vec2 x) vec3 floor(vec3 x) vec4 floor(vec4 x)  The floor function returns the largest integer number that is smaller or equal to x. The input parameter can be a floating scalar or a float vector. In case of a float vector the operation is done component-wise.  Side note: The return value is of type floating scalar or float vector although the result of the operation is an integer.
	floor($2)
snippet for for( ; ; ){ 	//code }  The keyword for is used to describe a loop that is controlled by a counter. The parentheses enclose three expressions that initialize, check and update the variable used as counter. The body defined by curly braces encloses the statements that are executed at each pass of the loop.  for(int i = 0; i <= 99; i++){ 	aFunction(); }  The execution of a single pass or the whole loop can be aborted by using a continue or a break statement respectively.
	for(int $2 = 0; $2 < $3; $2++){
		
	}
snippet fract float fract(float x) vec2 fract(vec2 x) vec3 fract(vec3 x) vec4 fract(vec4 x)  The fract function returns the fractional part of x, i.e. x minus floor(x). The input parameter can be a floating scalar or a float vector. In case of a float vector the operation is done component-wise.
	fract($2)
snippet frexp split a floating point number
	frexp($2, $3)
snippet void main void main(void){ 	//code }  The keyword main is used to define the main function of a shader. This function is the entry point for the execution of every vertex and fragment shader. The main function takes no parameters and does not return a value.
	void main(){
		
	}
snippet gl_FragColor mediump vec4 gl_FragColor;  The built-in variable gl_FragColor is used by the fragment shader to hand over the color of the fragment to the OpenGL ES 2.0 pipeline. The variable is pre-declared as shown above that way the variable can be used in the fragment shader for an assignment without prior declaration. The values of the color vector are interpreted in the RGBA color space. The assignment of values to this variable is mandatory for the fragment shader.
	gl_FragColor
snippet gl_FragCoord mediump vec4 gl_FragCoord;  bool gl_FrontFacing;  The built-in variable gl_FragCoord is used by the OpenGL ES 2.0 pipeline to hand over the coordinates of the fragment to the fragment shader. The variable is read-only and the value is assigned by the OpenGL ES 2.0 pipeline. The values of the fragment coordinate vector are given in the window coordinate system.
	gl_FragCoord
snippet gl_FrontFacing The built-in variable gl_FrontFacing is used by the OpenGL ES 2.0 pipeline to hand over the information to the fragment shader if the fragment is part of a front-facing primitive (triangle). The variable is read-only and the value is assigned by the OpenGL ES 2.0 pipeline. The front-facing variable has a boolean value.
	gl_FrontFacing
snippet gl_MaxDrawBuffers const mediump int gl_MaxDrawBuffers = 1  The built-in constant gl_MaxDrawBuffers provides the maximum number of the available draw buffers. The value of this variable is 1 for all OpenGL ES 2.0 implementations.
	gl_MaxDrawBuffers
snippet gl_MaxFragmentUniformVectors const mediump int gl_MaxFragmentUniformVectors >= 16  The built-in constant gl_MaxFragmentUniformVectors provides the maximum number of uniform vectors that can be used by the fragment shader. The value of this variable is dependent on the OpenGL ES 2.0 implementation but has to be at least 16.
	gl_MaxFragmentUniformVectors
snippet gl_MaxTextureImageUnits const mediump int gl_MaxTextureImageUnits >= 8  The built-in constant gl_MaxTextureImageUnits provides the maximum number of texture units that can be used by the fragment shader. The value of this variable is dependent on the OpenGL ES 2.0 implementation but has to be at least 8.
	gl_MaxTextureImageUnits
snippet gl_PointCoord mediump int gl_PointCoord;  The built-in variable gl_PointCoord is used by the OpenGL ES 2.0 pipeline to hand over the coordinates of a point sprite to the fragment shader. The variable is read-only and the value is calculated and assigned by the OpenGL ES 2.0 pipeline based on the position and radius of the point sprite. Side note: A value for this variable is provided by the OpenGL ES 2.0 pipeline only if the rendered primitives are points.
	gl_PointCoord
snippet highp The qualifier highp is used to specify the highest available precision for a variable. The variable has to be an integer or a floating point scalar or a vector or matrix based on these types. The precision qualifier precedes the type in the variable declaration. In the vertex shader the use of a precision qualifier is optional. If no qualifier is given all variables are of highest precision. In the fragment shader a precision qualifier has to be used when declaring a variable unless a default precision has been defined for the specific type.  uniform highp vec3 lightDirection;  The actual range corresponding to a precision qualifier is dependent on the specific OpenGL ES implementation. Using a lower precision might have a positive effect on performance (frame rates) and power efficiency but might also cause a loss in rendering quality. The appropriate trade-off can only be determined by testing different precision configurations.
	highp
snippet if if(){ 	//code }  The keyword if is used to describe the conditional execution of a statement. The parentheses enclose the expression that defines the condition. The curly braces enclose the statements that are executed if the condition evaluates as true.  if(i != 0){ 	aFunction(); }  In contrast to a loop the statements in curly braces are executed only one time or not at all.
	if($2){
		
	}
snippet ifdef A check defining if GLES is available
	#ifdef GL_ES
	precision mediump float;
	#endif
snippet ifelse if(){ 	//code } else { 	//code }  The keyword else is used in conjunction with the keyword if to describe the alternative execution of a statement. The parentheses enclose the expression that defines the condition. The curly braces after the if statement enclose the statements that are executed if the condition evaluates as true. The curly braces after the else statement enclose the statements that are executed if the condition evaluates as false.  if(i != 0){ 	aFunction(); } else { 	bFunction(); }  Depending on the condition either the statements in the first curly braces or the statements in the second curly braces are executed.
	if($2){
		
	} else {
		
	}
snippet in The qualifier in is used to mark a parameter as read-only when a function is declared. The parameter will be passed by value to the function and the value can not be modified by the function. The above function declaration shows the three possible parameter qualifiers. The usage of the read-only qualifier is not necessary since this is the default if no qualifier is specified.
	in
snippet inout The qualifier inout is used to mark a parameter as read-write when a function is declared. The parameter will be passed by reference to the function and is initialized, i.e. the value can be read. The value can be modified by the function and the changes are preserved after the function exits. The above function declaration shows the three possible parameter qualifiers. The usage of the read-only qualifier is not necessary since this is the default if no qualifier is specified.
	inout
snippet inversesqrt float inversesqrt(float x) vec2 inversesqrt(vec2 x) vec3 inversesqrt(vec3 x) vec4 inversesqrt(vec4 x)  The inversesqrt function returns the inverse square root of x, i.e. the reciprocal of the square root. The input parameter can be a floating scalar or a float vector. In case of a float vector the operation is done component-wise.
	inversesqrt($2)
snippet ldexp assemble a floating point number from a value and exponent
	ldexp($2, $3)
snippet length float length(float x) float length(vec2 x) float length(vec3 x) float length(vec4 x)  The length function returns the length of a vector defined by the Euclidean norm, i.e. the square root of the sum of the squared components. The input parameter can be a floating scalar or a float vector. In case of a floating scalar the length function is trivial and returns the absolute value.
	length($2)
snippet log float log(float x) vec2 log(vec2 x) vec3 log(vec3 x) vec4 log(vec4 x)  The log function returns the power to which the constant e has to be raised to produce x. The input parameter can be a floating scalar or a float vector. In case of a float vector the operation is done component-wise.
	log($2)
snippet log2 float log2(float x) vec2 log2(vec2 x) vec3 log2(vec3 x) vec4 log2(vec4 x)  The log2 function returns the power to which 2 has to be raised to produce x. The input parameter can be a floating scalar or a float vector. In case of a float vector the operation is done component-wise.
	log2($2)
snippet lowp The qualifier lowp is used to specify the lowest available precision for a variable. The variable has to be an integer or a floating point scalar or a vector or matrix based on these types. The precision qualifier precedes the type in the variable declaration. In the vertex shader the use of a precision qualifier is optional. If no qualifier is given all variables are of highest precision. In the fragment shader a precision qualifier has to be used when declaring a variable unless a default precision has been defined for the specific type.  varying lowp vec4 colorVarying;  The actual range corresponding to a precision qualifier is dependent on the specific OpenGL ES implementation. Using a lower precision might have a positive effect on performance (frame rates) and power efficiency but might also cause a loss in rendering quality. The appropriate trade-off can only be determined by testing different precision configurations.
	lowp
snippet mat2 The data type mat2 is used for floating point matrices with two times two components in column major order. There are several ways to initialize a matrix: • Components are specified by providing a scalar value for each component (first example). The matrix is filled column by column. • Components are specified by providing one scalar value. This value is used for the components on the main diagonal (the second example is equivalent to the first). • Components are specified by providing a combination of vectors and scalars. The respective values are used to initialize the components column by column. The arguments of the constructor must have at least as many components as the matrix that is initialized.
	mat2($2, $3)
snippet mat3 The data type mat3 is used for floating point matrices with three times three components in column major order. There are several ways to initialize a matrix: • Components are specified by providing a scalar value for each component (first example). The matrix is filled column by column. • Components are specified by providing one scalar value. This value is used for the components on the main diagonal (the second example is equivalent to the first). • Components are specified by providing a combination of vectors and scalars. The respective values are used to initialize the components column by column. The arguments of the constructor must have at least as many components as the matrix that is initialized.
	mat3($2, $3, $4)
snippet mat4 The data type mat4 is used for floating point matrices with four times four components in column major order. There are several ways to initialize a matrix: • Components are specified by providing a scalar value for each component (first example). The matrix is filled column by column. • Components are specified by providing one scalar value. This value is used for the components on the main diagonal (the second example is equivalent to the first). • Components are specified by providing a combination of vectors and scalars. The respective values are used to initialize the components column by column. The arguments of the constructor must have at least as many components as the matrix that is initialized.
	mat4($2, $3, $4, $5)
snippet max float max(float x, float y) vec2 max(vec2 x, vec2 y) vec3 max(vec3 x, vec3 y) vec4 max(vec4 x, vec4 y)  The max function returns the larger of the two arguments. The input parameters can be floating scalars or float vectors. In case of float vectors the operation is done component-wise.  float max(float x, float y) vec2 max(vec2 x, float y) vec3 max(vec3 x, float y) vec4 max(vec4 x, float y)  There is also a variation of the max function where the second parameter is always a floating scalar.
	max($2, $3)
snippet mediump The qualifier mediump is used to specify a precision between the highest and lowest available precision for a variable. The variable has to be an integer or a floating point scalar or a vector or matrix based on these types. The precision qualifier precedes the type in the variable declaration. In the vertex shader the use of a precision qualifier is optional. If no qualifier is given all variables are of highest precision. In the fragment shader a precision qualifier has to be used when declaring a variable unless a default precision has been defined for the specific type.  varying mediump vec2 textureCoordinate;  The actual range corresponding to a precision qualifier is dependent on the specific OpenGL ES implementation. Using a lower precision might have a positive effect on performance (frame rates) and power efficiency but might also cause a loss in rendering quality. The appropriate trade-off can only be determined by testing different precision configurations.
	mediump
snippet min float min(float x, float y) vec2 min(vec2 x, vec2 y) vec3 min(vec3 x, vec3 y) vec4 min(vec4 x, vec4 y)  The min function returns the smaller of the two arguments. The input parameters can be floating scalars or float vectors. In case of float vectors the operation is done component-wise. float min(float x, float y) vec2 min(vec2 x, float y) vec3 min(vec3 x, float y) vec4 min(vec4 x, float y)  There is also a variation of the min function where the second parameter is always a floating scalar.
	min($2, $3)
snippet mix float mix(float x, float y, float a) vec2 mix(vec2 x, vec2 y, vec2 a) vec3 mix(vec3 x, vec3 y, vec3 a) vec4 mix(vec4 x, vec4 y, vec4 a)  The mix function returns the linear blend of x and y, i.e. the product of x and (1 - a) plus the product of y and a. The input parameters can be floating scalars or float vectors. In case of float vectors the operation is done component-wise.  float mix(float x, float y, float a) vec2 mix(vec2 x, vec2 y, float a) vec3 mix(vec3 x, vec3 y, float a) vec4 mix(vec4 x, vec4 y, float a)  There is also a variation of the mix function where the third parameter is always a floating scalar.
	mix($2, $3, $4)
snippet mod float mod(float x, float y) vec2 mod(vec2 x, vec2 y) vec3 mod(vec3 x, vec3 y) vec4 mod(vec4 x, vec4 y)  The mod function returns x minus the product of y and floor(x/y). The input parameters can be floating scalars or float vectors. In case of float vectors the operation is done component-wise.  Side note: If x and y are integers the return value is the remainder of the division of x by y as expected.  float mod(float x, float y) vec2 mod(vec2 x, float y) vec3 mod(vec3 x, float y) vec4 mod(vec4 x, float y)  There is also a variation of the mod function where the second parameter is always a floating scalar.
	mod($2, $3)
snippet modf separate a value into its integer and fractional components
	modf($2, $3)
snippet noise1d noise1d function
	float noise1d(float v){
		return cos(v + cos(v * 90.1415) * 100.1415) * 0.5 + 0.5;
	}
snippet normalize float normalize(float x) vec2 normalize(vec2 x) vec3 normalize(vec3 x) vec4 normalize(vec4 x)  The normalize function returns a vector with length 1.0 that is parallel to x, i.e. x divided by its length. The input parameter can be a floating scalar or a float vector. In case of a floating scalar the normalize function is trivial and returns 1.0.
	normalize($2)
snippet out The qualifier out is used to mark a parameter as write-only when a function is declared. The parameter will be passed by reference to the function but it is not initialized, i.e. the value can not be read. The value can be modified by the function and the changes are preserved after the function exits. The above function declaration shows the three possible parameter qualifiers. The usage of the read-only qualifier is not necessary since this is the default if no qualifier is specified.
	out
snippet pow float pow(float x, float y) vec2 pow(vec2 x, vec2 y) vec3 pow(vec3 x, vec3 y) vec4 pow(vec4 x, vec4 y)  The power function returns x raised to the power of y. The input parameters can be floating scalars or float vectors. In case of float vectors the operation is done component-wise.
	pow($2, $3)
snippet precision The keyword precision is used in conjunction with a precision qualifier and a data type to specify the default precision for that data type. The type has to be an integer or a floating point scalar or a vector or matrix based on these types. In the vertex shader all variables are of highest precision by default. The default can be changed defining another default precision. In the fragment shader a precision qualifier has to be used when declaring a variable unless a default precision has been defined for the specific type.  precision highp float;  The actual range corresponding to a precision qualifier is dependent on the specific OpenGL ES implementation. Using a lower precision might have a positive effect on performance (frame rates) and power efficiency but might also cause a loss in rendering quality. The appropriate trade-off can only be determined by testing different precision configurations.
	precision
snippet radians float radians(float degrees) vec2 radians(vec2 degrees) vec3 radians(vec3 degrees) vec4 radians(vec4 degrees)  The radians function converts degrees to radians. The input parameter can be a floating scalar or a float vector. In case of a float vector all components are converted from degrees to radians separately.
	radians($2)
snippet random2d random 2d function
	float random2d(vec2 coord){
		return fract(sin(dot(coord.xy, vec2(12.9898, 78.233))) * 43758.5453);
	}
snippet reflect float reflect(float I, float N) vec2 reflect(vec2 I, vec2 N) vec3 reflect(vec3 I, vec3 N) vec4 reflect(vec4 I, vec4 N)  The reflect function returns a vector that points in the direction of reflection. The function has two input parameters of the type floating scalar or float vector: I, the incident vector, and N, the normal vector of the reflecting surface.  Side note: To obtain the desired result the vector N has to be normalized. The reflection vector always has the same length as the incident vector. From this it follows that the reflection vector is normalized if N and I are both normalized.
	reflect($2, $3)
snippet refract float refract(float I, float N, float eta) vec2 refract(vec2 I, vec2 N, float eta) vec3 refract(vec3 I, vec3 N, float eta) vec4 refract(vec4 I, vec4 N, float eta)  The refract function returns a vector that points in the direction of refraction. The function has two input parameters of the type floating scalar or float vector and one input parameter of the type floating scalar: I, the incident vector, N, the normal vector of the refracting surface, and eta, the ratio of indices of refraction.  Side note: To obtain the desired result the vectors I and N have to be normalized.
	refract($2, $3, $4)
snippet return The keyword return is used to define a proper exit for a function. If the function has the return type void no value is passed back to the caller of the function.  return aValue;  If the function has a non-void return type a parameter of the same type has to be included in the statement. The value is passed back to the caller of the function.
	return;
snippet rotate rotate
	mat2 rotate(float angle){
		return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
	}
snippet round find the nearest integer less than or equal to the parameter - The fraction 0.5 will round in a direction chosen by the implementation, presumably the direction that is fastest. This includes the possibility that round(x) returns the same value as roundEven(x) for all values of x
	round($2)
snippet roundEven find the nearest even integer to the parameter - The fractional part of 0.5 will round toward the nearest even integer. For example, both 3.5 and 4.5 will round to 4.0.
	roundEven($2)
snippet scale scale
	mat2 scale(vec2 scale){
		return mat2(scale.x, 0.0, 0.0, scale.y);
	}
snippet sign float sign(float x) vec2 sign(vec2 x) vec3 sign(vec3 x) vec4 sign(vec4 x)  The sign function returns 1.0 when x is positive, 0.0 when x is zero and -1.0 when x is negative. The input parameter can be a floating scalar or a float vector. In case of a float vector the operation is done component-wise.
	sign($2)
snippet simple setup Starter code including 'ifdef' check, u_ methods & the main
	#ifdef GL_ES
	precision mediump float;
	#endif
	
	uniform float u_time;
	uniform vec2 u_resolution;
	uniform vec2 u_mouse;
	
	void main(){
		vec2 coord = gl_FragCoord.xy;
		vec3 color = vec3(0.0);
	
		gl_FragColor = vec4(color, 1.0);
	}
snippet sin float sin(float angle) vec2 sin(vec2 angle) vec3 sin(vec3 angle) vec4 sin(vec4 angle)  The sin function returns the sine of an angle in radians. The input parameter can be a floating scalar or a float vector. In case of a float vector the sine is calculated separately for every component.
	sin($2)
snippet sinh return the hyperbolic sine of the parameter
	sinh($2)
snippet smoothstep float smoothstep(float edge0, float edge1, float x) vec2 smoothstep(vec2 edge0, vec2 edge1, vec2 x) vec3 smoothstep(vec3 edge0, vec3 edge1, vec3 x) vec4 smoothstep(vec4 edge0, vec4 edge1, vec4 x)  The smoothstep function returns 0.0 if x is smaller then edge0 and 1.0 if x is larger than edge1. Otherwise the return value is interpolated between 0.0 and 1.0 using Hermite polynomials. The input parameters can be floating scalars or float vectors. In case of float vectors the operation is done component-wise.  float smoothstep(float edge0, float edge1, float x) vec2 smoothstep(float edge0, float edge1, vec2 x) vec3 smoothstep(float edge0, float edge1, vec3 x) vec4 smoothstep(float edge0, float edge1, vec4 x)  There is also a variation of the smoothstep function where the edge0 and edge1 parameters are always floating scalars.
	smoothstep($2, $3, $4)
snippet sqrt float sqrt(float x) vec2 sqrt(vec2 x) vec3 sqrt(vec3 x) vec4 sqrt(vec4 x)  The sqrt function returns the square root of x. The input parameter can be a floating scalar or a float vector. In case of a float vector the operation is done component-wise.
	sqrt($2)
snippet step float step(float edge, float x) vec2 step(vec2 edge, vec2 x) vec3 step(vec3 edge, vec3 x) vec4 step(vec4 edge, vec4 x)  The step function returns 0.0 if x is smaller then edge and otherwise 1.0. The input parameters can be floating scalars or float vectors. In case of float vectors the operation is done component-wise.  float step(float edge, float x) vec2 step(float edge, vec2 x) vec3 step(float edge, vec3 x) vec4 step(float edge, vec4 x)  There is also a variation of the step function where the edge parameter is always a floating scalar.
	step($2, $3)
snippet tan float tan(float angle) vec2 tan(vec2 angle) vec3 tan(vec3 angle) vec4 tan(vec4 angle)  The tan function returns the tangent of an angle in radians. The input parameter can be a floating scalar or a float vector. In case of a float vector the tangent is calculated separately for every component.
	tan($2)
snippet tanh return the hyperbolic tangent of the parameter
	tanh($2)
snippet texture2D vec4 texture2D(sampler2D sampler, vec2 coord) vec4 texture2D(sampler2D sampler, vec2 coord, float bias)  The texture2D function returns a texel, i.e. the (color) value of the texture for the given coordinates. The function has one input parameter of the type sampler2D and one input parameter of the type vec2 : sampler, the uniform the texture is bound to, and coord, the 2-dimensional coordinates of the texel to look up.  There is an optional third input parameter of the type float: bias. After calculating the appropriate level of detail for a texture with mipmaps the bias is added before the actual texture lookup operation is executed.  Side note: On iOS devices texture lookup functionality is only available in the fragment shader.
	texture2D
snippet textureCube vec4 textureCube(samplerCube sampler, vec3 coord) vec4 textureCube(samplerCube sampler, vec3 coord, float bias)  The textureCube function returns a texel, i.e. the (color) value of the texture for the given coordinates. The function has one input parameter of the type samplerCube and one input parameter of the type vec3 : sampler, the uniform the texture is bound to, and coord, the 3-dimensional coordinates of the texel to look up.  There is an optional third input parameter of the type float: bias. After calculating the appropriate level of detail for a texture with mipmaps the bias is added before the actual texture lookup operation is executed.  Side note: On iOS devices texture lookup functionality is only available in the fragment shader.
	textureCube
snippet trunc find the nearest integer less than or equal to the parameter
	trunc($2)
snippet uniform The qualifier uniform is used to declare variables that are shared between a shader and the OpenGL ES environment. Uniforms can be used in the vertex shader and the fragment shader and they must have global scope. The same uniform variable can be used in the vertex and the fragment shader, but since both shaders share the same name space the declaration has to be identical. Uniforms are used to specify properties of the object that is rendered. Examples are the projection matrix, the light position or the material color of the object. Uniforms are read-only variables, i.e. their value can not be changed in the shader. Side note: Since a uniform is never initialized in the shader it has to be loaded with data by the application executing the shader.
	uniform
snippet varying The qualifier varying is used to declare variables that are shared between the vertex shader and the fragment shader. Varying are used for information that is calculated in the vertex shader and should be handed over to the fragment shader. Both shaders have to declare the varying and the declarations must be identical. The vertex shader initializes the varying for each vertex. After that the per vertex data of the varying is interpolated during rasterization before being handed over to the fragment shader. The varying qualifier can only be used with floating point scalar, floating point vectors and (floating point) matrices as well as arrays containing these types.
	varying
snippet vec2 The data type vec2 is used for floating point vectors with two components. There are several ways to initialize a vector: • Components are specified by providing a scalar value for each component (first example). • Components are specified by providing one scalar value. This value is used for all components (the second example is equivalent to the first). • Components are specified by providing a vector of higher dimension. The respective values are used to initialize the components (the second and third example are equivalent).  Side note: The vector constructors can be used to cast between different vector types since type conversions are done automatically for each component.
	vec2($2, $3)
snippet vec3 The data type vec3 is used for floating point vectors with three components. There are several ways to initialize a vector: • Components are specified by providing a scalar value for each component (first example). • Components are specified by providing one scalar value. This value is used for all components (the second example is equivalent to the first). Components are specified by providing a vector of higher dimension. The respective values are used to initialize the components (the second and third example are equivalent).• Components are specified by providing a combination of vectors and/or scalars. The respective values are used to initialize the vector (the fifth and sixth example are equivalent). The arguments of the constructor must have at least as many components as the vector that is initialized.  Side note: The vector constructors can be used to cast between different vector types since type conversions are done automatically for each component.
	vec3($2, $3, $4)
snippet vec4 The data type vec4 is used for floating point vectors with four components. There are several ways to initialize a vector: • Components are specified by providing a scalar value for each component (first example). • Components are specified by providing one scalar value. This value is used for all components (the second example is equivalent to the first). • Components are specified by providing a combination of vectors and scalars. The respective values are used to initialize the components (the third and fourth example are equivalent). The arguments of the constructor must have at least as many components as the vector that is initialized.  Side note: The vector constructors can be used to cast between different vector types since type conversions are done automatically for each component.
	vec4($2, $3, $4, $5)
snippet void void main(void); int aFunction(void); void bFunction(float);  The data type void is used when the parameter list of a function is empty and when a function does not return a value.
	void main(void);
snippet while while(){ 	//code }  The keyword while is used to describe a loop that is controlled by a condition. The parentheses enclose the expression that defines the condition. The body defined by curly braces encloses the statements that are executed at each pass of the loop.  while(i <= 99){ 	aFunction(); }  The execution of a single pass or the whole loop can be aborted by using a continue or a break statement respectively.
	while($2){
		
	}
