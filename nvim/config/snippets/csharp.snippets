# Generated by snippet-converter.nvim (https://github.com/smjonas/snippet-converter.nvim)

snippet ifd #if
	#if ${1:true}
	    $0
	#endif
snippet region #region
	#region ${1:Name}
	    $0
	#endregion
snippet attribute Attribute using recommended pattern
	[System.AttributeUsage(System.AttributeTargets.${1:All}, Inherited = ${2:false}, AllowMultiple = ${3:true})]
	sealed class ${4:My}Attribute : System.Attribute
	{
	    // See the attribute guidelines at
	    //  http://go.microsoft.com/fwlink/?LinkId=85236
	    readonly string positionalString;
	    
	    // This is a positional argument
	    public ${4:My}Attribute(string positionalString)
	    {
	        this.positionalString = positionalString;
	        
	        // TODO: Implement code here
	        ${5:throw new System.NotImplementedException();}
	    }
	    
	    public string PositionalString
	    {
	        get { return positionalString; }
	    }
	    
	    // This is a named argument
	    public int NamedInt { get; set; }
	}
snippet checked Checked block
	checked
	{
	    $0
	}
snippet class Class
	class ${1:Name}
	{
	    $0
	}
snippet cw Console.WriteLine
	System.Console.WriteLine($0);
snippet method Creates a Method structure
	${1:public} ${2:void} ${3:MyMethod}(${4:string} ${5:parameter})
	{
		$0
	}
snippet method_async Creates an async Method structure
	${1:public} async ${2:Task}<${3:object}> ${4:MyMethodAsync}(${5:string} ${6:parameter})
	{
		$0
	}
snippet else Else statement
	else
	{
	    $0
	}
snippet enum Enum
	enum ${1:Name}
	{
	    $0
	}
snippet exception Exception
	[System.Serializable]
	public class ${1:My}Exception : ${2:System.Exception}
	{
	    public ${1:My}Exception() { }
	    public ${1:My}Exception(string message) : base(message) { }
	    public ${1:My}Exception(string message, System.Exception inner) : base(message, inner) { }
	    protected ${1:My}Exception(
	        System.Runtime.Serialization.SerializationInfo info,
	        System.Runtime.Serialization.StreamingContext context) : base(info, context) { }
	}
snippet foreach Foreach statement
	foreach (${1:var} ${2:item} in ${3:collection})
	{
	    $0
	}
snippet equals Implementing Equals() according to guidelines
	// override object.Equals
	public override bool Equals(object obj)
	{
	    //
	    // See the full list of guidelines at
	    //   http://go.microsoft.com/fwlink/?LinkID=85237
	    // and also the guidance for operator== at
	    //   http://go.microsoft.com/fwlink/?LinkId=85238
	    //
	    
	    if (obj == null || GetType() != obj.GetType())
	    {
	        return false;
	    }
	    
	    // TODO: write your implementation of Equals() here
	    ${1:throw new System.NotImplementedException();}
	    return base.Equals (obj);
	}
	
	// override object.GetHashCode
	public override int GetHashCode()
	{
	    // TODO: write your implementation of GetHashCode() here
	    ${2:throw new System.NotImplementedException();}
	    return base.GetHashCode();
	}
snippet indexer Indexer
	${1:public} ${2:object} this[${3:int} index]
	{
	    get { $4 }
	    set { $0 }
	}
snippet interface Interface
	interface I${1:Name}
	{
	    $0
	}
snippet lock Lock statement
	lock (${1:this})
	{
	    $0
	}
snippet mbox MessageBox.Show
	System.Windows.Forms.MessageBox.Show("${1:Text}");$0
snippet iterindex Named iterator/indexer pair using a nested class
	public ${1:Name}Iterator ${1:Name}
	{
	    get
	    {
	        return new ${1:Name}Iterator(this);
	    }
	}
	
	public class ${1:Name}Iterator
	{
	    readonly ${2:ClassName} outer;
	    
	    internal ${1:Name}Iterator(${2:ClassName} outer)
	    {
	        this.outer = outer;
	    }
	    
	    // TODO: provide an appropriate implementation here
	    public int Length { get { return 1; } }
	    
	    public ${3:ElementType} this[int index]
	    {
	        get
	        {
	            //
	            // TODO: implement indexer here
	            //
	            // you have full access to ${2:ClassName} privates
	            //
	            ${4:throw new System.NotImplementedException();}
	            return default(${3:ElementType});
	        }
	    }
	    
	    public System.Collections.Generic.IEnumerator<${3:ElementType}> GetEnumerator()
	    {
	        for (int i = 0; i < this.Length; i++)
	        {
	            yield return this[i];
	        }
	    }
	}
snippet namespace Namespace
	namespace ${1:Name}
	{
	    $0
	}
snippet propfull Property and backing field
	private ${1:int} ${2:myVar};
	public ${1:int} ${3:MyProperty}
	{
	    get { return ${2:myVar}; }
	    set { ${2:myVar} = value; }
	}
	$0
snippet forr Reverse for loop
	for (int ${1:i} = ${2:length} - 1; ${1:i} >= 0 ; ${1:i}--)
	{
	    $0
	}
snippet invoke Safely invoking an event
	${1:EventHandler} temp = ${2:MyEvent};
	if (temp != null)
	{
	    temp($0);
	}
snippet iterator Simple iterator
	public System.Collections.Generic.IEnumerator<${1:ElementType}> GetEnumerator()
	{
	    $0throw new System.NotImplementedException();
	    yield return default(${1:ElementType});
	}
snippet struct Struct
	struct ${1:Name}
	{
	    $0
	}
snippet switch Switch statement
	switch (${1:switch_on})
	{
	    $0
	    default:
	}
snippet try Try catch
	try
	{
	    $1
	}
	catch (${2:System.Exception})
	{
	    $0
	    throw;
	}
snippet tryf Try finally
	try
	{
	    $1
	}
	finally
	{
	    $0
	}
snippet unchecked Unchecked block
	unchecked
	{
	    $0
	}
snippet unsafe Unsafe statement
	unsafe
	{
	    $0
	}
snippet using Using statement
	using (${1:resource})
	{
	    $0
	}
snippet while While loop
	while (${1:true})
	{
	    $0
	}
snippet cls Create new class
	${1:public} class ${2:`!v expand('%:t:r')`}
	{
		$0
	}
snippet ctor constructor
	${1:public} ${2:`!v expand('%:t:r')`}(${3:Parameters})
	{
	    $0
	}
snippet do do...while loop
	do
	{
	    $0
	} while (${1:true});
snippet else if else-if statement
	else if (${1:true})
	{
	    $0
	}
snippet for for loop
	for (int ${1:i} = 0; ${1:i} < ${2:length}; ${1:i}++)
	{
	    $0
	}
snippet if if statement
	if (${1:true})
	{
	    $0
	}
snippet prop An automatically implemented property. C# 3.0 or higher
	public ${1:int} ${2:MyProperty} { get; set; }$0
snippet propg An automatically implemented property with a 'get' accessor and a private 'set' accessor. C# 3.0 or higher
	public ${1:int} ${2:MyProperty} { get; private set; }$0
snippet sim int Main()
	static int Main(string[] args)
	{
	    $0
	    return 0;
	}
snippet svm void Main()
	static void Main(string[] args)
	{
	    $0
	}
snippet fact create xunit test method
	[Fact]
	public void ${1:TestName}()
	{
	//Given
	
	//When
	
	//Then
	}$0
